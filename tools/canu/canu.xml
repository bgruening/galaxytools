<tool id="canu" name="Canu" version="1.7">
    <description>Assembler optimized for long error-prone reads</description>
    <requirements>
        <requirement type="package" version="1.7">canu</requirement>
    </requirements>
    <version_command>canu --version</version_command>
    <command detect_error="exit_code">
    <![CDATA[

    #for $counter, $input in enumerate($inputs):
        #if $input.ext in ['fastq.gz', 'fasta.gz']
            ## linking does not work
            cp '$input' ./input_${counter}.gz &&
        #end if
    #end for

    canu
        $stage
        -p canu
        -d out_dir
        #if $s:
            -s '$s'
        #end if
        genomeSize=$genomeSize
        #if $rawErrorRate:
            rawErrorRate=$rawErrorRate
        #end if
        #if $correctedErrorRate:
            correctedErrorRate=$correctedErrorRate
        #end if
        minReadLength=$minReadLength
        minOverlapLength=$minOverlapLength
        corOutCoverage=$corOutCoverage
        contigFilter='
            ${contigFilter.minReads}
            ${contigFilter.minLength}
            ${contigFilter.singleReadSpan}
            ${contigFilter.lowCovSpan}
            ${contigFilter.lowCovDepth}
        '
        genomeSize=$genomeSize
        stopOnReadQuality=false
        minThreads=\${GALAXY_SLOTS:-1}
        maxThreads=\${GALAXY_SLOTS:-1}
        obtovlThreads=\${GALAXY_SLOTS:-1}
        utgovlThreads=\${GALAXY_SLOTS:-1}
        batThreads=\${GALAXY_SLOTS:-1}
        batMemory=\${GALAXY_MEMORY_MB:-8}
        gfaThreads=\${GALAXY_SLOTS:-1}
        corThreads=\${GALAXY_SLOTS:-1}
        cnsThreads=\${GALAXY_SLOTS:-1}
        gnuplotTested=true
        useGrid=false
        $mode
        #for $counter, $input in enumerate($inputs):
            #if $input.ext in ['fastq.gz', 'fasta.gz']
                ./input_${counter}.gz
            #else:
                '$input'
            #end if
        #end for
        2>&1
    ]]>
    </command>
    <inputs>
        <param name="inputs" type="data" format="fasta,fasta.gz,fastq,fastq.gz" multiple="true" label="Input reads" />
        <param name="mode" type="select" label="Mode">
            <option value="-nanopore-raw" selected="true">Nanopore raw</option>
            <option value="-nanopore-corrected">Nanopore corrected</option>
            <option value="-pacbio-raw">PacBio raw</option>
            <option value="-pacbio-corrected">PacBio corrected</option>
        </param>
        <param name="stage" type="select" label="To restrict canu to only a specific stage, use">
            <option value="" selected="true">all</option>
            <option value="-correct">generate corrected reads</option>
            <option value="-trim">generate trimmed reads</option>
            <option value="-assemble">generate an assembly</option>
            <option value="-trim-assemble">generate trimmed reads and then assemble them</option>
        </param>
        <param argument="genomeSize" type="text" label="Estimated genome size (e.g. 80m, 15k, 2g)" />
        <param argument="rawErrorRate" type="float" value="" optional="true" min="0" max="1"
            label="Maximum raw overlap mismatch" help="The defaults are 0.300 for PacBio reads and 0.500 for Nanopore reads." />
        <param argument="correctedErrorRate" type="float" value="" optional="true" min="0" max="1"
            label="Maximum corrected overlap mismatch" help="The allowed difference in an overlap between two corrected reads.  Assemblies of
                low coverage or data with biological differences will benefit from a slight increase
                in this.  Defaults are 0.045 for PacBio reads and 0.144 for Nanopore reads." />
        <param argument="minReadLength" type="integer" value="1000" min="1" label="Minimum read length" />
        <param argument="minOverlapLength" type="integer" value="500" min="1" label="Minimum overlap" />
        <param argument="corOutCoverage" type="integer" value="40" min="1" label="Target coverage for corrected reads" />
        <param argument="-s" type="data" format="txt" optional="true" label="Additonal options" help="Additional specifications provided in a canu spec file." />

        <section name="contigFilter" title="Contig Filters">
            <param argument="minReads" type="integer" value="2" min="0" label="Minimum reads" />
            <param argument="minLength" type="integer" value="0" min="0" label="Minimum length" />
            <param argument="singleReadSpan" type="float" value="1.0" min="0.0" max="1.0" label="Maximum single read span (fraction)" />
            <param argument="lowCovSpan" type="float" value="0.5" min="0.0" max="1.0" label="Low coverage span (fraction)" />
            <param argument="lowCovDepth" type="integer" value="5" min="0" label="Low coverage depth" />
        </section>
    </inputs>
    <outputs>
        <data name="contigs" format="fasta" from_work_dir="out_dir/canu.contigs.fasta" label="${tool.name} on ${on_string} (contigs)">
            <filter>stage is ''</filter>
        </data>
        <data name="unassembled" format="fasta" from_work_dir="out_dir/canu.unassembled.fasta" label="${tool.name} on ${on_string} (contigs)">
            <filter>stage is ''</filter>
        </data>
        <data name="unitigs" format="fasta" from_work_dir="out_dir/canu.unitigs.fasta" label="${tool.name} on ${on_string} (unitigs)">
            <filter>stage is ''</filter>
        </data>
        <data name="corrected_reads" format="fasta.gz" from_work_dir="out_dir/canu.correctedReads.fasta.gz" label="${tool.name} on ${on_string} (unitigs)">
            <filter>stage is '-correct'</filter>
        </data>
    </outputs>
    <tests>
        <test expect_num_outputs="3">
            <!-- test single input -->
            <param name="inputs" ftype="fastq" value="bowtie2-fq1.fq"/>
            <param name="genomeSize" value="80m" />
            <param name="minReadLength" value="10" />
            <param name="minOverlapLength" value="5" />
            <output name="contigs" ftype="fasta" file="canu_contigs_result1.fa"/>
            <output name="unitigs" ftype="fasta" file="canu_unitigs_result1.fa"/>
            <output name="unassembled" ftype="fasta" file="canu_unassembled_result1.fa"/>
        </test>
        <test expect_num_outputs="3">
            <!-- test multiple input -->
            <param name="inputs" ftype="fastq" value="bowtie2-fq1.fq"/>
            <param name="genomeSize" value="80m" />
            <param name="minReadLength" value="10" />
            <param name="minOverlapLength" value="5" />
            <output name="contigs" ftype="fasta" file="canu_contigs_result2.fa"/>
            <output name="unitigs" ftype="fasta" file="canu_unitigs_result2.fa"/>
            <output name="unassembled" ftype="fasta" file="canu_unassembled_result2.fa"/>
        </test>
        <test expect_num_outputs="1">
            <!-- test only -correct -->
            <param name="inputs" ftype="fastq" value="bowtie2-fq1.fq"/>
            <param name="stage" value="-correct"/>
            <param name="genomeSize" value="80m" />
            <param name="minReadLength" value="10" />
            <param name="minOverlapLength" value="5" />
            <section name="contigFilter">
                <param name="minReads" value="10" />
            </section>
            <output name="corrected_reads" ftype="fasta.gz" file="canu_corrected_reads.fa.gz"/>
        </test>
    </tests>
    <help>
    <![CDATA[

Canu specializes in assembling PacBio or Oxford Nanopore sequences. Canu operates in three phases: correction, trimming and assembly.
The correction phase will improve the accuracy of bases in reads. The trimming phase will trim reads to the portion that appears to
be high-quality sequence, removing suspicious regions such as remaining SMRTbell adapter. The assembly phase will order the reads
into contigs, generate consensus sequences and create graphs of alternate paths.

For eukaryotic genomes, coverage more than 20x is enough to outperform current hybrid methods, however, between 30x and 60x
coverage is the recommended minimum. More coverage will let Canu use longer reads for assembly, which will result in better assemblies.

http://canu.readthedocs.io

    ]]>
    </help>
    <citations>
        <citation type="doi">10.1101/gr.215087.116</citation>
        <citation type="doi">10.1093/bioinformatics/btw753</citation>
        <citation type="doi">10.1038/nbt.3238</citation>
        <citation type="doi">10.1126/science.287.5461.2196</citation>
        <citation type="doi">10.1038/nmeth.4035</citation>
        <citation type="doi">10.1038/nmeth.2474</citation>
    </citations>
</tool>

<!--
MMapBlockSize                           Number of reads per 1GB; memory * blockSize = the size of  block loaded into memory per job
MMapMerSize                             K-mer size for seeds in minmap
MhapBlockSize                           Number of reads per 1GB; memory * blockSize = the size of  block loaded into memory per job
MhapFilterThreshold                     Value between 0 and 1. kmers which comprise more than this percentage of the input are downweighted
MhapFilterUnique                        Expert option: True or false, supress the low-frequency k-mer distribution based on them being likely noise and not true overlaps. Threshold auto-computed based on error rate and coverage.
MhapMerSize                             K-mer size for seeds in mhap
MhapNoTf                                Expert option: True or false, do not use tf weighting, only idf of tf-idf.
MhapOptions                             Expert option: free-form parameters to pass to MHAP.
MhapOrderedMerSize                      K-mer size for second-stage filter in mhap
MhapSensitivity                         Coarse sensitivity level: 'low', 'normal' or 'high'.  Set automatically based on coverage; 'high' <= 30x < 'normal' < 60x <= 'low'
MhapVersion                             Version of the MHAP jar file to use
Overlapper                              Which overlap algorithm to use for unitig construction
OvlFilter                               Filter overlaps based on expected kmers vs observed kmers
OvlFrequentMers                         Do not seed overlaps with these kmers (fasta format)
OvlHashBits                             Width of the kmer hash.  Width 22=1gb, 23=2gb, 24=4gb, 25=8gb.  Plus 10b per utgOvlHashBlockLength
OvlHashBlockLength                      Amount of sequence (bp) to load into the overlap hash table
OvlHashLoad                             Maximum hash table load.  If set too high, table lookups are inefficent; if too low, search overhead dominates run time; default 0.75
OvlMerDistinct                          K-mer frequency threshold; the least frequent fraction of distinct mers can seed overlaps
OvlMerSize                              K-mer size for seeds in overlaps
OvlMerThreshold                         K-mer frequency threshold; mers more frequent than this count are ignored; default 'auto'
OvlMerTotal                             K-mer frequency threshold; the least frequent fraction of all mers can seed overlaps
OvlRefBlockLength                       Amount of sequence (bp) to search against the hash table per batch
ReAlign                                 Refine overlaps by computing the actual alignment: 'true' or 'false'.  Not useful for overlapper=ovl.  Uses utgOvlErrorRate
batConcurrency                          Unused, only one process supported
batMemory                               Approximate maximum memory usage, in gigabytes, default is the maxMemory limit
batOptions                              Advanced options to bogart
batStageSpace                           Amount of local disk space needed to stage data for unitig construction jobs
batThreads                              Number of threads to use; default is the maxThreads limit
cnsConcurrency                          If grid not enabled, number of unitig consensus jobs to run at the same time; default is n_proc / n_threads
cnsConsensus                            Which consensus algorithm to use; 'pbdagcon' (fast, reliable); 'utgcns' (multialignment output); 'quick' (single read mosaic); default 'pbdagcon'
cnsErrorRate                            Consensus expects alignments at about this error rate
cnsMaxCoverage                          Limit unitig consensus to at most this coverage; default '0' = unlimited
cnsMemory                               Amount of memory, in gigabytes, to use for unitig consensus jobs
cnsPartitionMin                         Don't make a consensus partition with fewer than N reads
cnsPartitions                           Partition consensus into N jobs
cnsStageSpace                           Amount of local disk space needed to stage data for unitig consensus jobs
cnsThreads                              Number of threads to use for unitig consensus jobs
contigFilter                            Parameters to filter out 'unassembled' unitigs.  Five values: minReads minLength singleReadSpan lowCovFraction lowCovDepth
corConcurrency                          If grid not enabled, number of read correction jobs to run at the same time; default is n_proc / n_threads
corConsensus                            Which consensus algorithm to use; only 'falcon' is supported; default 'falcon'
corErrorRate                            Only use raw alignments below this error rate to construct corrected reads
corFilter                               Method to filter short reads from correction; 'quick' or 'expensive'; default 'expensive'
corMMapBlockSize                        Number of reads per 1GB; memory * blockSize = the size of  block loaded into memory per job
corMMapMerSize                          K-mer size for seeds in minmap
corMaxEvidenceCoverageGlobal            Limit reads used for correction to supporting at most this coverage; default: '1.0x' = 1.0 * estimated coverage
corMaxEvidenceCoverageLocal             Limit reads being corrected to at most this much evidence coverage; default: '2.0x' = 2.0 * estimated coverage
corMaxEvidenceErate                     Limit read correction to only overlaps at or below this fraction error; default: unlimited
corMemory                               Amount of memory, in gigabytes, to use for read correction jobs
corMhapBlockSize                        Number of reads per 1GB; memory * blockSize = the size of  block loaded into memory per job
corMhapFilterThreshold                  Value between 0 and 1. kmers which comprise more than this percentage of the input are downweighted
corMhapFilterUnique                     Expert option: True or false, supress the low-frequency k-mer distribution based on them being likely noise and not true overlaps. Threshold auto-computed based on error rate and coverage.
corMhapMerSize                          K-mer size for seeds in mhap
corMhapNoTf                             Expert option: True or false, do not use tf weighting, only idf of tf-idf.
corMhapOptions                          Expert option: free-form parameters to pass to MHAP.
corMhapOrderedMerSize                   K-mer size for second-stage filter in mhap
corMhapSensitivity                      Coarse sensitivity level: 'low', 'normal' or 'high'.  Set automatically based on coverage; 'high' <= 30x < 'normal' < 60x <= 'low'
corMhapVersion                          Version of the MHAP jar file to use
corMinCoverage                          Minimum number of bases supporting each corrected base, if less than this sequences are split; default based on input read coverage: 0 <= 30x < 4 < 60x <= 4
corMinEvidenceLength                    Limit read correction to only overlaps longer than this; default: unlimited
corOutCoverage                          Only correct the longest reads up to this coverage; default 40
corOverlapper                           Which overlap algorithm to use for correction
corOvlErrorRate                         Overlaps above this error rate are not computed
corOvlFilter                            Filter overlaps based on expected kmers vs observed kmers
corOvlFrequentMers                      Do not seed overlaps with these kmers (fasta format)
corOvlHashBits                          Width of the kmer hash.  Width 22=1gb, 23=2gb, 24=4gb, 25=8gb.  Plus 10b per corOvlHashBlockLength
corOvlHashBlockLength                   Amount of sequence (bp) to load into the overlap hash table
corOvlHashLoad                          Maximum hash table load.  If set too high, table lookups are inefficent; if too low, search overhead dominates run time; default 0.75
corOvlMerDistinct                       K-mer frequency threshold; the least frequent fraction of distinct mers can seed overlaps
corOvlMerSize                           K-mer size for seeds in overlaps
corOvlMerThreshold                      K-mer frequency threshold; mers more frequent than this count are ignored; default 'auto'
corOvlMerTotal                          K-mer frequency threshold; the least frequent fraction of all mers can seed overlaps
corOvlRefBlockLength                    Amount of sequence (bp) to search against the hash table per batch
corPartitionMin                         Don't make a read correction partition with fewer than N reads
corPartitions                           Partition read correction into N jobs
corReAlign                              Refine overlaps by computing the actual alignment: 'true' or 'false'.  Not useful for overlapper=ovl.  Uses corOvlErrorRate
corStageSpace                           Amount of local disk space needed to stage data for read correction jobs
corThreads                              Number of threads to use for read correction jobs
cormhapConcurrency                      If grid not enabled, number of mhap overlaps for correction jobs to run at the same time; default is n_proc / n_threads
cormhapMemory                           Amount of memory, in gigabytes, to use for mhap overlaps for correction jobs
cormhapStageSpace                       Amount of local disk space needed to stage data for mhap overlaps for correction jobs
cormhapThreads                          Number of threads to use for mhap overlaps for correction jobs
cormmapConcurrency                      If grid not enabled, number of mmap overlaps for correction jobs to run at the same time; default is n_proc / n_threads
cormmapMemory                           Amount of memory, in gigabytes, to use for mmap overlaps for correction jobs
cormmapStageSpace                       Amount of local disk space needed to stage data for mmap overlaps for correction jobs
cormmapThreads                          Number of threads to use for mmap overlaps for correction jobs
corovlConcurrency                       If grid not enabled, number of overlaps for correction jobs to run at the same time; default is n_proc / n_threads
corovlMemory                            Amount of memory, in gigabytes, to use for overlaps for correction jobs
corovlStageSpace                        Amount of local disk space needed to stage data for overlaps for correction jobs
corovlThreads                           Number of threads to use for overlaps for correction jobs
correctedErrorRate                      Expected fraction error in an alignment of two corrected reads
enableOEA                               Do overlap error adjustment - comprises two steps: read error detection (RED) and overlap error adjustment (OEA); default 'true'
genomeSize                              An estimate of the size of the genome
gfaConcurrency                          If grid not enabled, number of graph alignment and processing jobs to run at the same time; default is n_proc / n_threads
gfaMemory                               Amount of memory, in gigabytes, to use for graph alignment and processing jobs
gfaStageSpace                           Amount of local disk space needed to stage data for graph alignment and processing jobs
gfaThreads                              Number of threads to use for graph alignment and processing jobs
gnuplot                                 Path to the gnuplot executable
gnuplotImageFormat                      Image format that gnuplot will generate.  Default: based on gnuplot, 'png', 'svg' or 'gif'
gnuplotTested                           If set, skip the initial testing of gnuplot
maxMemory                               Maximum memory to use by any component of the assembler
maxThreads                              Maximum number of compute threads to use by any component of the assembler
merylConcurrency                        Unused, there is only one process
merylMemory                             Amount of memory, in gigabytes, to use for mer counting
merylStageSpace                         Amount of local disk space needed to stage data for mer counting jobs
merylThreads                            Number of threads to use for mer counting
minMemory                               Minimum amount of memory needed to compute the assembly (do not set unless prompted!)
minOverlapLength                        Overlaps shorter than this length are not computed; default 500
minReadLength                           Reads shorter than this length are not loaded into the assembler; default 1000
minThreads                              Minimum number of compute threads suggested to compute the assembly
obtErrorRate                            Stringency of overlaps to use for trimming
obtMMapBlockSize                        Number of reads per 1GB; memory * blockSize = the size of  block loaded into memory per job
obtMMapMerSize                          K-mer size for seeds in minmap
obtMhapBlockSize                        Number of reads per 1GB; memory * blockSize = the size of  block loaded into memory per job
obtMhapFilterThreshold                  Value between 0 and 1. kmers which comprise more than this percentage of the input are downweighted
obtMhapFilterUnique                     Expert option: True or false, supress the low-frequency k-mer distribution based on them being likely noise and not true overlaps. Threshold auto-computed based on error rate and coverage.
obtMhapMerSize                          K-mer size for seeds in mhap
obtMhapNoTf                             Expert option: True or false, do not use tf weighting, only idf of tf-idf.
obtMhapOptions                          Expert option: free-form parameters to pass to MHAP.
obtMhapOrderedMerSize                   K-mer size for second-stage filter in mhap
obtMhapSensitivity                      Coarse sensitivity level: 'low', 'normal' or 'high'.  Set automatically based on coverage; 'high' <= 30x < 'normal' < 60x <= 'low'
obtMhapVersion                          Version of the MHAP jar file to use
obtOverlapper                           Which overlap algorithm to use for overlap based trimming
obtOvlErrorRate                         Overlaps at or below this error rate are used to trim reads
obtOvlFilter                            Filter overlaps based on expected kmers vs observed kmers
obtOvlFrequentMers                      Do not seed overlaps with these kmers (fasta format)
obtOvlHashBits                          Width of the kmer hash.  Width 22=1gb, 23=2gb, 24=4gb, 25=8gb.  Plus 10b per obtOvlHashBlockLength
obtOvlHashBlockLength                   Amount of sequence (bp) to load into the overlap hash table
obtOvlHashLoad                          Maximum hash table load.  If set too high, table lookups are inefficent; if too low, search overhead dominates run time; default 0.75
obtOvlMerDistinct                       K-mer frequency threshold; the least frequent fraction of distinct mers can seed overlaps
obtOvlMerSize                           K-mer size for seeds in overlaps
obtOvlMerThreshold                      K-mer frequency threshold; mers more frequent than this count are ignored; default 'auto'
obtOvlMerTotal                          K-mer frequency threshold; the least frequent fraction of all mers can seed overlaps
obtOvlRefBlockLength                    Amount of sequence (bp) to search against the hash table per batch
obtReAlign                              Refine overlaps by computing the actual alignment: 'true' or 'false'.  Not useful for overlapper=ovl.  Uses obtOvlErrorRate
obtmhapConcurrency                      If grid not enabled, number of mhap overlaps for trimming jobs to run at the same time; default is n_proc / n_threads
obtmhapMemory                           Amount of memory, in gigabytes, to use for mhap overlaps for trimming jobs
obtmhapStageSpace                       Amount of local disk space needed to stage data for mhap overlaps for trimming jobs
obtmhapThreads                          Number of threads to use for mhap overlaps for trimming jobs
obtmmapConcurrency                      If grid not enabled, number of mmap overlaps for trimming jobs to run at the same time; default is n_proc / n_threads
obtmmapMemory                           Amount of memory, in gigabytes, to use for mmap overlaps for trimming jobs
obtmmapStageSpace                       Amount of local disk space needed to stage data for mmap overlaps for trimming jobs
obtmmapThreads                          Number of threads to use for mmap overlaps for trimming jobs
obtovlConcurrency                       If grid not enabled, number of overlaps for trimming jobs to run at the same time; default is n_proc / n_threads
obtovlMemory                            Amount of memory, in gigabytes, to use for overlaps for trimming jobs
obtovlStageSpace                        Amount of local disk space needed to stage data for overlaps for trimming jobs
obtovlThreads                           Number of threads to use for overlaps for trimming jobs
oeaBatchLength                          Number of bases per overlap error correction batch
oeaBatchSize                            Number of reads per overlap error correction batch
oeaConcurrency                          If grid not enabled, number of overlap error adjustment jobs to run at the same time; default is n_proc / n_threads
oeaMemory                               Amount of memory, in gigabytes, to use for overlap error adjustment jobs
oeaStageSpace                           Amount of local disk space needed to stage data for overlap error adjustment jobs
oeaThreads                              Number of threads to use for overlap error adjustment jobs
onFailure                               Full path to command to run on failure
onSuccess                               Full path to command to run on successful completion
ovbConcurrency                          If grid not enabled, number of overlap store bucketizing jobs to run at the same time; default is n_proc / n_threads
ovbMemory                               Amount of memory, in gigabytes, to use for overlap store bucketizing jobs
ovbStageSpace                           Amount of local disk space needed to stage data for overlap store bucketizing jobs
ovbThreads                              Number of threads to use for overlap store bucketizing jobs
ovsConcurrency                          If grid not enabled, number of overlap store sorting jobs to run at the same time; default is n_proc / n_threads
ovsMemory                               Amount of memory, in gigabytes, to use for overlap store sorting jobs
ovsMethod                               Use the 'sequential' or 'parallel' algorithm for constructing an overlap store; default 'sequential'
ovsStageSpace                           Amount of local disk space needed to stage data for overlap store sorting jobs
ovsThreads                              Number of threads to use for overlap store sorting jobs
preExec                                 A command line to run at the start of Canu execution scripts
rawErrorRate                            Expected fraction error in an alignment of two uncorrected reads
redBatchLength                          Number of bases per fragment error detection batch
redBatchSize                            Number of reads per fragment error detection batch
redConcurrency                          If grid not enabled, number of read error detection jobs to run at the same time; default is n_proc / n_threads
redMemory                               Amount of memory, in gigabytes, to use for read error detection jobs
redStageSpace                           Amount of local disk space needed to stage data for read error detection jobs
redThreads                              Number of threads to use for read error detection jobs
saveMerCounts                           Save full mer counting results, sometimes useful
saveOverlaps                            Save intermediate overlap files, almost never a good idea
saveReadCorrections                     Save intermediate read correction files, almost never a good idea
saveReadHaplotypes                      Save intermediate read haplotype files, almost never a good idea
saveReads                               Save intermediate corrected and trimmed reads to asm.correctedReads.fasta.gz and asm.trimmedReads.fasta.gz
stopOnReadQuality                       Stop if a significant portion of the input data is too short or has quality value or base composition errors
trimReadsCoverage                       Minimum depth of evidence to retain bases; default '1'
trimReadsOverlap                        Minimum overlap between evidence to make contiguous trim; default '1'
unitigger                               Which unitig algorithm to use; only 'bogart' supported; default 'bogart'
utgErrorRate                            Overlaps at or below this error rate are used to construct contigs
utgGraphDeviation                       Overlaps this much above median will not be used for initial graph construction
utgMMapBlockSize                        Number of reads per 1GB; memory * blockSize = the size of  block loaded into memory per job
utgMMapMerSize                          K-mer size for seeds in minmap
utgMhapBlockSize                        Number of reads per 1GB; memory * blockSize = the size of  block loaded into memory per job
utgMhapFilterThreshold                  Value between 0 and 1. kmers which comprise more than this percentage of the input are downweighted
utgMhapFilterUnique                     Expert option: True or false, supress the low-frequency k-mer distribution based on them being likely noise and not true overlaps. Threshold auto-computed based on error rate and coverage.
utgMhapMerSize                          K-mer size for seeds in mhap
utgMhapNoTf                             Expert option: True or false, do not use tf weighting, only idf of tf-idf.
utgMhapOptions                          Expert option: free-form parameters to pass to MHAP.
utgMhapOrderedMerSize                   K-mer size for second-stage filter in mhap
utgMhapSensitivity                      Coarse sensitivity level: 'low', 'normal' or 'high'.  Set automatically based on coverage; 'high' <= 30x < 'normal' < 60x <= 'low'
utgMhapVersion                          Version of the MHAP jar file to use
utgOverlapper                           Which overlap algorithm to use for unitig construction
utgOvlErrorRate                         Overlaps at or below this error rate are used to trim reads
utgOvlFilter                            Filter overlaps based on expected kmers vs observed kmers
utgOvlFrequentMers                      Do not seed overlaps with these kmers (fasta format)
utgOvlHashBits                          Width of the kmer hash.  Width 22=1gb, 23=2gb, 24=4gb, 25=8gb.  Plus 10b per utgOvlHashBlockLength
utgOvlHashBlockLength                   Amount of sequence (bp) to load into the overlap hash table
utgOvlHashLoad                          Maximum hash table load.  If set too high, table lookups are inefficent; if too low, search overhead dominates run time; default 0.75
utgOvlMerDistinct                       K-mer frequency threshold; the least frequent fraction of distinct mers can seed overlaps
utgOvlMerSize                           K-mer size for seeds in overlaps
utgOvlMerThreshold                      K-mer frequency threshold; mers more frequent than this count are ignored; default 'auto'
utgOvlMerTotal                          K-mer frequency threshold; the least frequent fraction of all mers can seed overlaps
utgOvlRefBlockLength                    Amount of sequence (bp) to search against the hash table per batch
utgReAlign                              Refine overlaps by computing the actual alignment: 'true' or 'false'.  Not useful for overlapper=ovl.  Uses utgOvlErrorRate
utgRepeatConfusedBP                     Repeats where the next best edge is at least this many bp shorter will not be split
utgRepeatDeviation                      Overlaps this much above mean unitig error rate will not be used for repeat splitting
utgmhapConcurrency                      If grid not enabled, number of mhap overlaps for unitig construction jobs to run at the same time; default is n_proc / n_threads
utgmhapMemory                           Amount of memory, in gigabytes, to use for mhap overlaps for unitig construction jobs
utgmhapStageSpace                       Amount of local disk space needed to stage data for mhap overlaps for unitig construction jobs
utgmhapThreads                          Number of threads to use for mhap overlaps for unitig construction jobs
utgmmapConcurrency                      If grid not enabled, number of mmap overlaps for unitig construction jobs to run at the same time; default is n_proc / n_threads
utgmmapMemory                           Amount of memory, in gigabytes, to use for mmap overlaps for unitig construction jobs
utgmmapStageSpace                       Amount of local disk space needed to stage data for mmap overlaps for unitig construction jobs
utgmmapThreads                          Number of threads to use for mmap overlaps for unitig construction jobs
utgovlConcurrency                       If grid not enabled, number of overlaps for unitig construction jobs to run at the same time; default is n_proc / n_threads
utgovlMemory                            Amount of memory, in gigabytes, to use for overlaps for unitig construction jobs
utgovlStageSpace                        Amount of local disk space needed to stage data for overlaps for unitig construction jobs
utgovlThreads                           Number of threads to use for overlaps for unitig construction jobs

-->



