<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RNAlib-2.1.2: Calculating Partition Functions and Pair Probabilities</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>Calculating Partition Functions and Pair Probabilities<br>
<small>
[<a class="el" href="group__folding__routines.html">RNA Secondary Structure Folding</a>]</small>
</h1>
<p>
Collaboration diagram for Calculating Partition Functions and Pair Probabilities:<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mea__fold.html">Compute the structure with maximum expected accuracy (MEA)</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__centroid__fold.html">Compute the centroid structure</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pf__cofold.html">Partition Function for two hybridized Sequences</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__up__cofold.html">Partition Function for two hybridized Sequences as a stepwise Process</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__consensus__pf__fold.html">Partition Function and Base Pair Probabilities for Sequence Alignment(s)</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__local__pf__fold.html">Partition functions for locally stable secondary structures</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kl__neighborhood__pf.html">Calculate Partition Functions of a Distance Based Partitioning</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pf__fold.html#gf5fd8cc57e35ddd713122c886f215e15">pf_fold_par</a> (const char *sequence, char *structure, <a class="el" href="structpf__paramT.html">pf_paramT</a> *parameters, int calculate_bppm, int is_constrained, int is_circular)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the partition function <img class="formulaInl" alt="$Q$" src="form_18.png"> for a given RNA sequence.  <a href="#gf5fd8cc57e35ddd713122c886f215e15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pf__fold.html#g25c82afd90b779becea09444dbe39bcf">pf_fold</a> (const char *sequence, char *structure)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the partition function <img class="formulaInl" alt="$Q$" src="form_18.png"> of an RNA sequence.  <a href="#g25c82afd90b779becea09444dbe39bcf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pf__fold.html#gc9027d62aebf1b8fa7c767fb221992be">pf_circ_fold</a> (const char *sequence, char *structure)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the partition function of a circular RNA sequence.  <a href="#gc9027d62aebf1b8fa7c767fb221992be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pf__fold.html#gba5cac9edbc48e9d0e8c8fe83f4d0781">free_pf_arrays</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free arrays for the partition function recursions.  <a href="#gba5cac9edbc48e9d0e8c8fe83f4d0781"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pf__fold.html#g72007173e035f9605597fd0b0f101984">update_pf_params</a> (int length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recalculate energy parameters.  <a href="#g72007173e035f9605597fd0b0f101984"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g60d7c405d606c8b2756e0891b5b19d6e"></a><!-- doxytag: member="pf_fold::update_pf_params_par" ref="g60d7c405d606c8b2756e0891b5b19d6e" args="(int length, pf_paramT *parameters)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pf__fold.html#g60d7c405d606c8b2756e0891b5b19d6e">update_pf_params_par</a> (int length, <a class="el" href="structpf__paramT.html">pf_paramT</a> *parameters)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recalculate energy parameters. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pf__fold.html#g3a9f8c18a6043cfc8bbc30a8a37e3969">export_bppm</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to the base pair probability array<p>
Accessing the base pair probabilities for a pair (i,j) is achieved by.  <a href="#g3a9f8c18a6043cfc8bbc30a8a37e3969"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pf__fold.html#g4099fa99067719874f214e3d329fbeea">assign_plist_from_pr</a> (<a class="el" href="structplist.html">plist</a> **pl, double *probs, int length, double cutoff)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a plist from a probability matrix.  <a href="#g4099fa99067719874f214e3d329fbeea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pf__fold.html#g537854c3a777887c94bb0bed2baa26b0">get_pf_arrays</a> (short **S_p, short **S1_p, char **ptype_p, double **qb_p, double **qm_p, double **q1k_p, double **qln_p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the pointers to (almost) all relavant computation arrays used in partition function computation.  <a href="#g537854c3a777887c94bb0bed2baa26b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pf__fold.html#ge6a7ca930ed3c671b4dbdd1bcd9717b0">mean_bp_distance</a> (int length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mean base pair distance of the last partition function computation.  <a href="#ge6a7ca930ed3c671b4dbdd1bcd9717b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pf__fold.html#gb98e05fef617c0333942a089e93be018">mean_bp_distance_pr</a> (int length, double *<a class="el" href="fold__vars_8h.html#75a6fe753fbc832775d21e537ad1b21e">pr</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mean base pair distance in the thermodynamic ensemble.  <a href="#gb98e05fef617c0333942a089e93be018"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gf5fd8cc57e35ddd713122c886f215e15"></a><!-- doxytag: member="part_func.h::pf_fold_par" ref="gf5fd8cc57e35ddd713122c886f215e15" args="(const char *sequence, char *structure, pf_paramT *parameters, int calculate_bppm, int is_constrained, int is_circular)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pf_fold_par           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>structure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpf__paramT.html">pf_paramT</a> *&nbsp;</td>
          <td class="paramname"> <em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>calculate_bppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_constrained</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>is_circular</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the partition function <img class="formulaInl" alt="$Q$" src="form_18.png"> for a given RNA sequence. 
<p>
If <em>structure</em> is not a NULL pointer on input, it contains on return a string consisting of the letters " . , | { } ( ) " denoting bases that are essentially unpaired, weakly paired, strongly paired without preference, weakly upstream (downstream) paired, or strongly up- (down-)stream paired bases, respectively. If <a class="el" href="fold__vars_8h.html#85ce01be2d212e2043761bdb64fcce60">fold_constrained</a> is not 0, the <em>structure</em> string is interpreted on input as a list of constraints for the folding. The character "x" marks bases that must be unpaired, matching brackets " ( ) " denote base pairs, all other characters are ignored. Any pairs conflicting with the constraint will be forbidden. This is usually sufficient to ensure the constraints are honored. If tha parameter calculate_bppm is set to 0 base pairing probabilities will not be computed (saving CPU time), otherwise after calculations took place <a class="el" href="fold__vars_8h.html#75a6fe753fbc832775d21e537ad1b21e">pr</a> will contain the probability that bases <em>i</em> and <em>j</em> pair.<p>
<dl compact><dt><b>Note:</b></dt><dd>The global array <a class="el" href="fold__vars_8h.html#75a6fe753fbc832775d21e537ad1b21e">pr</a> is deprecated and the user who wants the calculated base pair probabilities for further computations is advised to use the function <a class="el" href="group__pf__fold.html#g3a9f8c18a6043cfc8bbc30a8a37e3969">export_bppm()</a> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>After successful run the hidden folding matrices are filled with the appropriate Boltzmann factors. Depending on whether the global variable <a class="el" href="fold__vars_8h.html#d18a5668c071dfcf0cb088899aa32106">do_backtrack</a> was set the base pair probabilities are already computed and may be accessed for further usage via the <a class="el" href="group__pf__fold.html#g3a9f8c18a6043cfc8bbc30a8a37e3969">export_bppm()</a> function. A call of <a class="el" href="group__pf__fold.html#gba5cac9edbc48e9d0e8c8fe83f4d0781">free_pf_arrays()</a> will free all memory allocated by this function. Successive calls will first free previously allocated memory before starting the computation. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__pf__fold.html#g25c82afd90b779becea09444dbe39bcf">pf_fold()</a>, <a class="el" href="group__pf__fold.html#gc9027d62aebf1b8fa7c767fb221992be">pf_circ_fold()</a>, <a class="el" href="part__func_8h.html#8bc7fb2b347512e67f413e5327c8f1a2">bppm_to_structure()</a>, <a class="el" href="group__pf__fold.html#g3a9f8c18a6043cfc8bbc30a8a37e3969">export_bppm()</a>, <a class="el" href="group__energy__parameters.html#gceda7aaccb2d4719f4821fe16b93c8d3">get_boltzmann_factors()</a>, <a class="el" href="group__pf__fold.html#gba5cac9edbc48e9d0e8c8fe83f4d0781">free_pf_arrays()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sequence</em>&nbsp;</td><td>The RNA sequence input </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>structure</em>&nbsp;</td><td>A pointer to a char array where a base pair probability information can be stored in a pseudo-dot-bracket notation (may be NULL, too) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parameters</em>&nbsp;</td><td>Data structure containing the precalculated Boltzmann factors </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>calculate_bppm</em>&nbsp;</td><td>Switch to Base pair probability calculations on/off (0==off) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>is_constrained</em>&nbsp;</td><td>Switch to indicate that a structure contraint is passed via the structure argument (0==off) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>is_circular</em>&nbsp;</td><td>Switch to (de-)activate postprocessing steps in case RNA sequence is circular (0==off) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Gibbs free energy of the ensemble (<img class="formulaInl" alt="$G = -RT \cdot \log(Q) $" src="form_19.png">) in kcal/mol </dd></dl>

</div>
</div><p>
<a class="anchor" name="g25c82afd90b779becea09444dbe39bcf"></a><!-- doxytag: member="part_func.h::pf_fold" ref="g25c82afd90b779becea09444dbe39bcf" args="(const char *sequence, char *structure)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pf_fold           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>structure</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the partition function <img class="formulaInl" alt="$Q$" src="form_18.png"> of an RNA sequence. 
<p>
If <em>structure</em> is not a NULL pointer on input, it contains on return a string consisting of the letters " . , | { } ( ) " denoting bases that are essentially unpaired, weakly paired, strongly paired without preference, weakly upstream (downstream) paired, or strongly up- (down-)stream paired bases, respectively. If <a class="el" href="fold__vars_8h.html#85ce01be2d212e2043761bdb64fcce60">fold_constrained</a> is not 0, the <em>structure</em> string is interpreted on input as a list of constraints for the folding. The character "x" marks bases that must be unpaired, matching brackets " ( ) " denote base pairs, all other characters are ignored. Any pairs conflicting with the constraint will be forbidden. This is usually sufficient to ensure the constraints are honored. If <a class="el" href="fold__vars_8h.html#d18a5668c071dfcf0cb088899aa32106">do_backtrack</a> has been set to 0 base pairing probabilities will not be computed (saving CPU time), otherwise <a class="el" href="fold__vars_8h.html#75a6fe753fbc832775d21e537ad1b21e">pr</a> will contain the probability that bases <em>i</em> and <em>j</em> pair.<p>
<dl compact><dt><b>Note:</b></dt><dd>The global array <a class="el" href="fold__vars_8h.html#75a6fe753fbc832775d21e537ad1b21e">pr</a> is deprecated and the user who wants the calculated base pair probabilities for further computations is advised to use the function <a class="el" href="group__pf__fold.html#g3a9f8c18a6043cfc8bbc30a8a37e3969">export_bppm()</a>. <p>
<b>OpenMP:</b> This function is not entirely threadsafe. While the recursions are working on their own copies of data the model details for the recursions are determined from the global settings just before entering the recursions. Consider using <a class="el" href="group__pf__fold.html#gf5fd8cc57e35ddd713122c886f215e15">pf_fold_par()</a> for a really threadsafe implementation. </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>This function takes its model details from the global variables provided in <em>RNAlib</em> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>After successful run the hidden folding matrices are filled with the appropriate Boltzmann factors. Depending on whether the global variable <a class="el" href="fold__vars_8h.html#d18a5668c071dfcf0cb088899aa32106">do_backtrack</a> was set the base pair probabilities are already computed and may be accessed for further usage via the <a class="el" href="group__pf__fold.html#g3a9f8c18a6043cfc8bbc30a8a37e3969">export_bppm()</a> function. A call of <a class="el" href="group__pf__fold.html#gba5cac9edbc48e9d0e8c8fe83f4d0781">free_pf_arrays()</a> will free all memory allocated by this function. Successive calls will first free previously allocated memory before starting the computation. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__pf__fold.html#gf5fd8cc57e35ddd713122c886f215e15">pf_fold_par()</a>, <a class="el" href="group__pf__fold.html#gc9027d62aebf1b8fa7c767fb221992be">pf_circ_fold()</a>, <a class="el" href="part__func_8h.html#8bc7fb2b347512e67f413e5327c8f1a2">bppm_to_structure()</a>, <a class="el" href="group__pf__fold.html#g3a9f8c18a6043cfc8bbc30a8a37e3969">export_bppm()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sequence</em>&nbsp;</td><td>The RNA sequence input </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>structure</em>&nbsp;</td><td>A pointer to a char array where a base pair probability information can be stored in a pseudo-dot-bracket notation (may be NULL, too) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Gibbs free energy of the ensemble (<img class="formulaInl" alt="$G = -RT \cdot \log(Q) $" src="form_19.png">) in kcal/mol </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc9027d62aebf1b8fa7c767fb221992be"></a><!-- doxytag: member="part_func.h::pf_circ_fold" ref="gc9027d62aebf1b8fa7c767fb221992be" args="(const char *sequence, char *structure)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pf_circ_fold           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>structure</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the partition function of a circular RNA sequence. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>The global array <a class="el" href="fold__vars_8h.html#75a6fe753fbc832775d21e537ad1b21e">pr</a> is deprecated and the user who wants the calculated base pair probabilities for further computations is advised to use the function <a class="el" href="group__pf__fold.html#g3a9f8c18a6043cfc8bbc30a8a37e3969">export_bppm()</a>. <p>
<b>OpenMP:</b> This function is not entirely threadsafe. While the recursions are working on their own copies of data the model details for the recursions are determined from the global settings just before entering the recursions. Consider using <a class="el" href="group__pf__fold.html#gf5fd8cc57e35ddd713122c886f215e15">pf_fold_par()</a> for a really threadsafe implementation. </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>This function takes its model details from the global variables provided in <em>RNAlib</em> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>After successful run the hidden folding matrices are filled with the appropriate Boltzmann factors. Depending on whether the global variable <a class="el" href="fold__vars_8h.html#d18a5668c071dfcf0cb088899aa32106">do_backtrack</a> was set the base pair probabilities are already computed and may be accessed for further usage via the <a class="el" href="group__pf__fold.html#g3a9f8c18a6043cfc8bbc30a8a37e3969">export_bppm()</a> function. A call of <a class="el" href="group__pf__fold.html#gba5cac9edbc48e9d0e8c8fe83f4d0781">free_pf_arrays()</a> will free all memory allocated by this function. Successive calls will first free previously allocated memory before starting the computation. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__pf__fold.html#gf5fd8cc57e35ddd713122c886f215e15">pf_fold_par()</a>, <a class="el" href="group__pf__fold.html#g25c82afd90b779becea09444dbe39bcf">pf_fold()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sequence</em>&nbsp;</td><td>The RNA sequence input </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>structure</em>&nbsp;</td><td>A pointer to a char array where a base pair probability information can be stored in a pseudo-dot-bracket notation (may be NULL, too) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Gibbs free energy of the ensemble (<img class="formulaInl" alt="$G = -RT \cdot \log(Q) $" src="form_19.png">) in kcal/mol </dd></dl>

</div>
</div><p>
<a class="anchor" name="gba5cac9edbc48e9d0e8c8fe83f4d0781"></a><!-- doxytag: member="part_func.h::free_pf_arrays" ref="gba5cac9edbc48e9d0e8c8fe83f4d0781" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_pf_arrays           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free arrays for the partition function recursions. 
<p>
Call this function if you want to free all allocated memory associated with the partition function forward recursion. <dl compact><dt><b>Note:</b></dt><dd>Successive calls of <a class="el" href="group__pf__fold.html#g25c82afd90b779becea09444dbe39bcf">pf_fold()</a>, <a class="el" href="group__pf__fold.html#gc9027d62aebf1b8fa7c767fb221992be">pf_circ_fold()</a> already check if they should free any memory from a previous run. <p>
<b>OpenMP notice:</b><br>
 This function should be called before leaving a thread in order to avoid leaking memory</dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>All memory allocated by <a class="el" href="group__pf__fold.html#gf5fd8cc57e35ddd713122c886f215e15">pf_fold_par()</a>, <a class="el" href="group__pf__fold.html#g25c82afd90b779becea09444dbe39bcf">pf_fold()</a> or <a class="el" href="group__pf__fold.html#gc9027d62aebf1b8fa7c767fb221992be">pf_circ_fold()</a> will be free'd </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__pf__fold.html#gf5fd8cc57e35ddd713122c886f215e15">pf_fold_par()</a>, <a class="el" href="group__pf__fold.html#g25c82afd90b779becea09444dbe39bcf">pf_fold()</a>, <a class="el" href="group__pf__fold.html#gc9027d62aebf1b8fa7c767fb221992be">pf_circ_fold()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g72007173e035f9605597fd0b0f101984"></a><!-- doxytag: member="part_func.h::update_pf_params" ref="g72007173e035f9605597fd0b0f101984" args="(int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_pf_params           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recalculate energy parameters. 
<p>
Call this function to recalculate the pair matrix and energy parameters after a change in folding parameters like <a class="el" href="fold__vars_8h.html#0b516316c5f7ab02f8d1a9fbc1ba2fbb">temperature</a> 
</div>
</div><p>
<a class="anchor" name="g3a9f8c18a6043cfc8bbc30a8a37e3969"></a><!-- doxytag: member="part_func.h::export_bppm" ref="g3a9f8c18a6043cfc8bbc30a8a37e3969" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* export_bppm           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the base pair probability array<p>
Accessing the base pair probabilities for a pair (i,j) is achieved by. 
<p>
<div class="fragment"><pre class="fragment">  FLT_OR_DBL *<a class="code" href="fold__vars_8h.html#75a6fe753fbc832775d21e537ad1b21e">pr</a>  = <a class="code" href="group__pf__fold.html#g3a9f8c18a6043cfc8bbc30a8a37e3969">export_bppm</a>();
  pr_ij           = pr[<a class="code" href="fold__vars_8h.html#e2e64f77fe25400c55cd38b8270db573">iindx</a>[i]-j];
</pre></div><p>
<dl compact><dt><b>Precondition:</b></dt><dd>Call <a class="el" href="group__pf__fold.html#gf5fd8cc57e35ddd713122c886f215e15">pf_fold_par()</a>, <a class="el" href="group__pf__fold.html#g25c82afd90b779becea09444dbe39bcf">pf_fold()</a> or <a class="el" href="group__pf__fold.html#gc9027d62aebf1b8fa7c767fb221992be">pf_circ_fold()</a> first to fill the base pair probability array</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__pf__fold.html#g25c82afd90b779becea09444dbe39bcf">pf_fold()</a>, <a class="el" href="group__pf__fold.html#gc9027d62aebf1b8fa7c767fb221992be">pf_circ_fold()</a>, <a class="el" href="utils_8h.html#361bacacd3717eb1b96c0a8dbae2184d">get_iindx()</a></dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to the base pair probability array </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4099fa99067719874f214e3d329fbeea"></a><!-- doxytag: member="part_func.h::assign_plist_from_pr" ref="g4099fa99067719874f214e3d329fbeea" args="(plist **pl, double *probs, int length, double cutoff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assign_plist_from_pr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplist.html">plist</a> **&nbsp;</td>
          <td class="paramname"> <em>pl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>probs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>cutoff</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a plist from a probability matrix. 
<p>
The probability matrix given is parsed and all pair probabilities above the given threshold are used to create an entry in the plist<p>
The end of the plist is marked by sequence positions i as well as j equal to 0. This condition should be used to stop looping over its entries<p>
<dl compact><dt><b>Note:</b></dt><dd>This function is threadsafe</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pl</em>&nbsp;</td><td>A pointer to the plist that is to be created </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>probs</em>&nbsp;</td><td>The probability matrix used for creting the plist </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the RNA sequence </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cutoff</em>&nbsp;</td><td>The cutoff value </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g537854c3a777887c94bb0bed2baa26b0"></a><!-- doxytag: member="part_func.h::get_pf_arrays" ref="g537854c3a777887c94bb0bed2baa26b0" args="(short **S_p, short **S1_p, char **ptype_p, double **qb_p, double **qm_p, double **q1k_p, double **qln_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_pf_arrays           </td>
          <td>(</td>
          <td class="paramtype">short **&nbsp;</td>
          <td class="paramname"> <em>S_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short **&nbsp;</td>
          <td class="paramname"> <em>S1_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>ptype_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>qb_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>qm_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>q1k_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>qln_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the pointers to (almost) all relavant computation arrays used in partition function computation. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>In order to assign meaningful pointers, you have to call <a class="el" href="group__pf__fold.html#gf5fd8cc57e35ddd713122c886f215e15">pf_fold_par()</a> or <a class="el" href="group__pf__fold.html#g25c82afd90b779becea09444dbe39bcf">pf_fold()</a> first! </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__pf__fold.html#gf5fd8cc57e35ddd713122c886f215e15">pf_fold_par()</a>, <a class="el" href="group__pf__fold.html#g25c82afd90b779becea09444dbe39bcf">pf_fold()</a>, <a class="el" href="group__pf__fold.html#gc9027d62aebf1b8fa7c767fb221992be">pf_circ_fold()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>S_p</em>&nbsp;</td><td>A pointer to the 'S' array (integer representation of nucleotides) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>S1_p</em>&nbsp;</td><td>A pointer to the 'S1' array (2nd integer representation of nucleotides) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>ptype_p</em>&nbsp;</td><td>A pointer to the pair type matrix </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>qb_p</em>&nbsp;</td><td>A pointer to the Q<sup>B</sup> matrix </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>qm_p</em>&nbsp;</td><td>A pointer to the Q<sup>M</sup> matrix </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>q1k_p</em>&nbsp;</td><td>A pointer to the 5' slice of the Q matrix (<img class="formulaInl" alt="$q1k(k) = Q(1, k)$" src="form_0.png">) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>qln_p</em>&nbsp;</td><td>A pointer to the 3' slice of the Q matrix (<img class="formulaInl" alt="$qln(l) = Q(l, n)$" src="form_1.png">) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Non Zero if everything went fine, 0 otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge6a7ca930ed3c671b4dbdd1bcd9717b0"></a><!-- doxytag: member="part_func.h::mean_bp_distance" ref="ge6a7ca930ed3c671b4dbdd1bcd9717b0" args="(int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mean_bp_distance           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mean base pair distance of the last partition function computation. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>To ensure thread-safety, use the function <a class="el" href="group__pf__fold.html#gb98e05fef617c0333942a089e93be018">mean_bp_distance_pr()</a> instead!</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__pf__fold.html#gb98e05fef617c0333942a089e93be018">mean_bp_distance_pr()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>mean base pair distance in thermodynamic ensemble </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb98e05fef617c0333942a089e93be018"></a><!-- doxytag: member="part_func.h::mean_bp_distance_pr" ref="gb98e05fef617c0333942a089e93be018" args="(int length, double *pr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mean_bp_distance_pr           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>pr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mean base pair distance in the thermodynamic ensemble. 
<p>
This is a threadsafe implementation of <a class="el" href="part__func_8h.html#b83fc8dea4ec3add6b237b86e2ce7286">mean_bp_dist()</a> !<p>
<img class="formulaInl" alt="$<d> = \sum_{a,b} p_a p_b d(S_a,S_b)$" src="form_22.png"><br>
 this can be computed from the pair probs <img class="formulaInl" alt="$p_ij$" src="form_23.png"> as<br>
 <img class="formulaInl" alt="$<d> = \sum_{ij} p_{ij}(1-p_{ij})$" src="form_24.png"><p>
<dl compact><dt><b>Note:</b></dt><dd>This function is threadsafe</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the sequence </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pr</em>&nbsp;</td><td>The matrix containing the base pair probabilities </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The mean pair distance of the structure ensemble </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Fri Jul 26 15:10:19 2013 for RNAlib-2.1.2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
