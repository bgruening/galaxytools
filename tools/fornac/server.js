// Usage node server.js [format] [input] [output]

if(process.argv.length < 7){
	console.log("Script expects 7 or more arguments.")
	console.log("Usage: node server.js [format] [input] [output]");
	process.exit();
}else{

	// Requirements
	var jsdom = require('jsdom');
	var fs = require("fs");
	const pnfs = require("pn/fs");
	const svg2png = require("svg2png");

	// Global variables
	var editorHtml;
	var tmpFileName = [];
	var tmpMultipleOutputs = [];
	var format = process.argv[2];
	var width = process.argv[3];
	var height = process.argv[4];
	var input = process.argv[5];
	var output = process.argv[6];
	var tool_directory = process.argv[7];

	function readInput() 
	{
		var temp1 = String(fs.readFileSync(input, "utf-8"));
		var count1 = (temp1.match(/Time/g) || []).length;
		if(count1 == 0) //If the input is a normal JSON file
		{
			var xxx = String(fs.readFileSync(input, "utf-8"));
			return fs.readFileSync(input, "utf-8");
		}
	    else //If the input is generated by antaRNA and has multiple sequences
	    {
	    	var index1 = temp1.search("Time");
    		var temp2 = temp1.substring(index1);
	        var temp3 = temp2.substring(19);
	        var finalJSON = "";
	    	for(i = 0; i < count1; i++)
	    	{
	    		
                if( i == (count1 - 1))
                {
                	for(j=0 ; j<temp3.length ; j++)
			        {
				
	                    if (temp3.charAt(j) == "A" || temp3.charAt(j) == "G" || temp3.charAt(j) == "C" || temp3.charAt(j) == "U"  )
	                    {
	                        var indexEND = j;
	                        break;
	                    } 
	                }
			        var temp4 = temp3.substring(0, indexEND-1);
			        var temp6 = temp4.replace(/^\s+|\s+$/g, '');
			        var temp5 = temp3.substring(indexEND);
			        var temp7 = temp5.replace(/^\s+|\s+$/g, '');
			        var final1_1 = '"structure" :'.concat('','"' + temp6);
			        var final1_2 = final1_1.concat('', '",');
			        var final2_1 = '"sequence" : "'.concat('', temp7);
			        var final2_2 = final2_1.concat('', '"')
			        finalJSON = finalJSON + '{\n    '+final1_2+'\n    '+final2_2+'\n}';
			        
	                
                }
                else
                {
                	var index2 = temp3.search(">");
                	var temp3_1 = temp3.substring(0, index2 -1);
                	var index2_1 = temp3.search("Time");
                	temp3 = temp3.substring(index2_1 + 19);
		             for(j=0 ; j<temp3_1.length ; j++)
			        {
				
	                    if (temp3_1.charAt(j) == "A" || temp3_1.charAt(j) == "G" || temp3_1.charAt(j) == "C" || temp3_1.charAt(j) == "U"  )
	                    {
	                        var indexEND = j;
	                        break;
	                    } 
	                }
			        var temp4 = temp3_1.substring(0, indexEND-1);
			        var temp6 = temp4.replace(/^\s+|\s+$/g, '');
			        var temp5 = temp3_1.substring(indexEND);
			        var temp7 = temp5.replace(/^\s+|\s+$/g, '');
			        var final1_1 = '"structure" :'.concat('','"' + temp6);
			        var final1_2 = final1_1.concat('', '",');
			        var final2_1 = '"sequence" : "'.concat('', temp7);
			        var final2_2 = final2_1.concat('', '"')
			        finalJSON = finalJSON + '{\n    '+final1_2+'\n    '+final2_2+'\n},\n';
			        
	                
       	        }

            }
            finalJSON = "[\n" + finalJSON + "\n]";
       	    return finalJSON;
	    }		
	}

	function readTmp(file) {
		return fs.readFileSync(file, "utf-8");
	}

	/** A function that loads the input file and then modifies the editor.html
	*	to change the input parameters for Fornac. It loads the structures and
	*	the nucleotides for the visualization.
	*/
	function writeInput(content, index) {
		content = JSON.stringify(content);
		editorHtml = fs.readFileSync(tool_directory + "editor.html", "utf-8");
		var newValue = editorHtml.replace(/<input>/, content)
								.replace(/<width>/g, width)
						 		.replace(/<height>/g, height);
		var removedExtension = cleanFileName(input);
		tmpFileName[index] = tool_directory + '/' + 'editor_' + removedExtension + "_" + index + '.html';
	  	fs.writeFileSync(tmpFileName[index], newValue, 'utf-8');
	}

	/** Removal of the prefixes of the full path and extension trimming.
	*/
	function cleanFileName(name){
		var parts = name.split("\/");
		var nameAndExtension = parts[parts.length - 1];
		return nameAndExtension.split("\.")[0];
	}

	/** Gets the extension of the given file name and cleans the path.
	*/
	function getExtension(name){
		var parts = name.split("\/");
		var nameAndExtension = parts[parts.length - 1];
		return nameAndExtension.split("\.")[1];
	}

	/** A function that deletes the temporary file that is used for the 
	*	particular input sequence. This file is generated from the writeInput()
	*	function.
	*/
	function deleteTmpFile(index) {
		fs.unlink(tmpFileName[index]);
	}

	/** Writes the output of the final file. Depending on the format it might be
	*	an svg, png or some other format file.
	*/
	function writeOutput(content, file){
		fs.writeFileSync(file, content, 'utf-8');
	}

	/** Processes and generates the svg, also adds the needed tags for it to be
	*	displayable as a xml file in browser.
	*/
	function generateSvg(window, file){
		// Get the css styles for the svg
	  	var svgStyle = window.$("style").html();
	  	// Svg attributes that are needed for standalone function
	  	// as a separate file
	  	var svg = window.$("svg").attr("viewBox", "0 0 " + width + " " + height);
	  	svg.attr("xmlns","http://www.w3.org/2000/svg");
	  	svg.attr("version","1.1");
	  	svg.attr("xmlns:xlink","http://www.w3.org/1999/xlink");
	  	svg.attr("width", width.toString());
	  	svg.attr("height", height.toString());
	  	// Locate the style inside the svg itself and fill it with
	  	// the previously loaded styles
	  	window.$("svg > style").html(''+svgStyle);
	  	var svgFinal = 
	  		`<?xml version="1.0" standalone="no"?>
			<?xml-stylesheet type="text/css" href="style8.css"?>
			<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
			` +
  			window.$("#rna_ss").html();
	    writeOutput(svgFinal, file);
	}

	/** Processes and generates the svg, also adds the needed tags for it to be
	*	displayable as a xml file in browser.
	*/
	function convertSvgToPng(tmpSvg, png){
		pnfs.readFile(tmpSvg)
		    .then(svg2png)
		    .then(buffer => fs.writeFile(png, buffer))
		    .catch(e => console.error(e));
	}

	/** A function that runs the JSDOM server and executes it with the needed options.
	*	The server is set to execute the javascripts so the svg can be generated.
	*/
	function runJSDOM(content, index){
		writeInput(content, index);

		// The config object is built for the jsdom options
		var config = {};

		config.file = tmpFileName[index];
		config.features = {
			FetchExternalResources : ['script'],
			ProcessExternalResources : ['script']
		};
		if(index == 0){
			tmpMultipleOutputs[index] = output;		
		}else{
			var extension = ".dat";
			if(format == "html"){
				extension = ".html";
			}
			tmpMultipleOutputs[index] = cleanFileName(output) + "_" + index + extension;
		}

		config.done = function (err, window) {
		  	if(format == "svg"){
		  		generateSvg(window, tmpMultipleOutputs[index]);
			}else if(format == "png"){
				var removedExtension = cleanFileName(this.file);
				var tmpSvg = removedExtension + ".svg";
			 	generateSvg(window, tmpSvg);
			 	convertSvgToPng(tmpSvg, tmpMultipleOutputs[index]);
				fs.unlink(tmpSvg);
			}else if(format == "html"){
	    		var html = readTmp(this.file);
	    		writeOutput(html, tmpMultipleOutputs[index]);
			}
			deleteTmpFile(index);
		}

		// Run the jsdom server and generate the output
		jsdom.env(config);
	}

	/** The function that contains the main logic.
	*/
	function main(){
		var content = JSON.parse(readInput());

		if(content.constructor === Array){
			for(index in content){
				
				runJSDOM(content[index], index);
			}
		}else{
			runJSDOM(content, 0);
		}
	}

	// Call to main
	main();
}