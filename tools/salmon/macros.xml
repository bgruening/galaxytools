<macros>
    <token name="@TOOL_VERSION@">1.10.1</token>
    <token name="@VERSION_SUFFIX@">4</token>
    <token name="@IDX_VERSION@">q7</token>
    <token name="@PROFILE_VERSION@">24.1</token>
    <xml name="xrefs">
        <xrefs>
            <xref type="bio.tools">salmon</xref>
        </xrefs>
    </xml>
    <xml name="requirements">
        <requirements>
            <requirement type="package" version="@TOOL_VERSION@">salmon</requirement>
            <requirement type="package" version="1.3">seqtk</requirement>
            <requirement type="package" version="1.16.1">samtools</requirement>
            <requirement type="package" version="0.2.0">vpolo</requirement>
            <requirement type="package" version="1.5.2">pandas</requirement>
            <requirement type="package" version="3.0.0">graphviz</requirement>
            <requirement type="package" version="1.9.3">scipy</requirement>
        </requirements>
    </xml>
    <xml name="version_command">
        <version_command><![CDATA[salmon --no-version-check --version | cut -d" " -f2]]></version_command>
    </xml>
    <xml name="orient">
        <param argument="--libType" name="orientation" type="select" label="Relative orientation of reads within a pair">
            <option value="M">Mates are oriented in the same direction (M = matching)</option>
            <option value="O">Mates are oriented away from each other (O = outward)</option>
            <option value="I" selected="true">Mates are oriented toward each other (I = inward)</option>
        </param>
    </xml>
    <xml name="stranded">
        <conditional name="libtype" >
            <param argument="--libType" name="strandedness" type="select" label="Specify the strandedness of the reads" help="--libtype">
                <option value="A" selected="true">Infer automatically (A)</option>
                <option value="U">Not stranded (U)</option>
                <option value="SF">read comes from the forward strand (SF)</option>
                <option value="SR">read comes from the reverse strand (SR)</option>
            </param>
            <yield/>
        </conditional>
    </xml>
    <xml name="stranded_se">
        <expand macro="stranded">
            <when value="A"/>
            <when value="U"/>
            <when value="SF"/>
            <when value="SR"/>
        </expand>
    </xml>
    <xml name="stranded_pe">
        <expand macro="stranded">
            <when value="A">
            </when>
            <when value="U">
                <expand macro="orient"/>
            </when>
            <when value="SF">
                <expand macro="orient"/>
            </when>
            <when value="SR">
                <expand macro="orient"/>
            </when>
        </expand>
    </xml>
    <xml name="index">
        <conditional name="refTranscriptSource">
            <param name="TranscriptSource" type="select" label="Select a reference transcriptome from your history or use a built-in index?"
                help="Built-ins were indexed using default options">
                <option value="indexed">Use a built-in index</option>
                <option value="history" selected="true">Use one from the history</option>
            </param>
            <when value="indexed">
                <param argument="--index" type="select" label="Select a reference transcriptome" help="If your transcriptome of interest is not listed, contact your Galaxy admin">
                    <options from_data_table="salmon_indexes_versioned">
                        <filter type="sort_by" column="2"/>
                        <filter type="static_value" column="4" value="@IDX_VERSION@" />
                        <validator type="no_options" message="No indexes are available for the selected input dataset"/>
                    </options>
                </param>
            </when>  <!-- build-in -->
            <when value="history">
                <section name="s_index" title="Salmon index" expanded="true">
                    <param argument="--transcripts" name="fasta" type="data" format="fasta" label="Transcripts FASTA file"/>
                    <param argument="--genome" type="data" format="fasta" optional="true" label="Reference genome" 
                        help="The reference genome is required for generating a decoy-away index. The decoy sequences are regions of the target genome 
                            that are sequence similar to annotated transcripts. These are the regions of the genome most likely to cause mismapping." />
                    <param argument="--kmerLen" name="kmer" type="integer" value="31" label="Kmer length"/>
                </section>
            </when>
        </conditional>
    </xml>
    <xml name="reads">
        <section name="input" title="Data input" expanded="true">
            <conditional name="single_or_paired">
                <param name="single_or_paired_opts" type="select" label="Is this library mate-paired?">
                    <option value="single">Single-end</option>
                    <option value="paired_collection">Paired-end Dataset Collection</option>
                </param>
                <when value="single">
                    <param argument="--unmatedReads" name="input_singles" type="data" format="fasta,fastqsanger,fastqsanger.gz,fastqsanger.bz2" label="FASTQ/FASTA file" help="FASTQ file." />
                    <expand macro="stranded_se"/>
                </when>
                <when value="paired_collection">
                    <param name="input_1" format="fasta,fastqsanger,fastqsanger.gz,fastqsanger.bz2" type="data_collection" collection_type="paired" label="FASTQ Paired Dataset" help="(--mates1,--mates2)" />
                    <expand macro="stranded_pe"/>
                </when>
            </conditional>
        </section>
        <!--Salmon quant type select: reads-based or alignment-based-->
        <param argument="--discardOrphansQuasi" type="boolean" truevalue="--discardOrphansQuasi" falsevalue="" checked="false" label="Discard orphan quasi" help="Discard orphan mappings in quasi-mapping mode. If this flag is passed then only paired mappings will be considered toward quantification estimates.  The default behavior is to consider orphan mappings if no valid paired mappings exist."/>
        <conditional name="validmap">
            <param name="validateMappings" type="select" label="Validate mappings" help="Validate mappings using alignment-based verifcation. If this flag is passed, quasi-mappings will be validated to ensure that they could give rise to a reasonable alignment before they are further used for quantification.">
                <option value="--validateMappings">True</option>
                <option value="" selected="true">False</option>
            </param>
            <when value="--validateMappings">
                <param argument="--minScoreFraction" type="float" value="0.65" label="Min Score Fraction" help="The fraction of the optimal possible alignment score that a mapping must achieve in order to be considered valid. Should be in (0,1].">
                    <validator type="in_range" min="0" exclude_max="1"/>
                </param>
                <param argument="--ma" name="matchScore" type="integer" value="2" label="Match Score" help="The value given to a match between read and reference nucleotides in an alignment."/>
                <param argument="--mp" name="mismatchPenalty" type="integer" value="-4" label="Mismatch Penalty" help="The value given to a mis-match between read and reference nucleotides in an alignment. This will be cast to a negative value."/>
                <param argument="--go" name="gapOpenPenalty" type="integer" value="6" label="Gap Open Penalty" help="The value given to a gap opening in an alignment."/>
                <param argument="--ge" name="gapExtensionPenalty" type="integer" value="2" label="Gap Extension Penalty" help="The value given to a gap extension in an alignment."/>
                <param argument="--mimicBT2" type="boolean" truevalue="--mimicBT2" falsevalue="" checked="false" label="Mimic Bowtie 2" help="Set flags to mimic parameters similar to Bowtie2 with --no-discordant and --no-mixed flags. This increases disallows dovetailing reads, and discards orphans. Note, this does not impose the very strict parameters assumed by RSEM+Bowtie2, like gapless alignments. For that behavior, use the --mimiStrictBT2 flag "/>
                <param argument="--mimicStrictBT2" type="boolean" truevalue="--mimicStrictBT2" falsevalue="" checked="false" label="Mimic Strict Bowtie 2" help="Set flags to mimic the very strict parameters used by RSEM+Bowtie2. This increases --minScoreFraction to 0.8, disallows dovetailing reads, discards orphans, and disallows gaps in alignments."/>
                <param argument="--hardFilter" type="boolean" truevalue="--hardFilter" falsevalue="" checked="false" label="Hard Filter" help="Instead of weighting mappings by their alignment score, this flag will discard any mappings with sub-optimal alignment score. The default option of soft-filtering (i.e. weighting mappings by their alignment score) usually yields slightly more accurate abundance estimates but this flag may be desirable if you want more accurate 'naive' equivalence classes, rather than range factorized equivalence classes."/>
            </when>
            <when value=""/>
        </conditional>
        <param argument="--consensusSlack" type="float" value="0.349999994" label="Consensus Slack" help="The amount of slack allowed in the quasi-mapping consensus mechanism.  Normally, a transcript must cover all hits to be considered for mapping. If this is set to a value, X, greater than 0, then a transcript can fail to cover up to X hits before it is discounted as a mapping candidate.  The default value of this option is 1 if --validateMappings is given and 0 otherwise.">
            <validator type="in_range" min="0" exclude_max="1"/>
        </param>
        <param name="dovetail" argument="--allowDovetail" label="Allow Dovetail" type="boolean" truevalue="--allowDovetail" falsevalue="" checked="false" help="Allow dovetail mappings"/>
        <param argument="--recoverOrphans" label="Recover Orphans" type="boolean" truevalue="--recoverOrphans" falsevalue="" checked="false" help="Attempt to recover the mates of orphaned reads. This uses edlib for orphan recovery, and so introduces some computational overhead, but it can improve sensitivity."/>
        <conditional name="bam_options">
            <param argument="--writeMappings" type="select" label="Write Mappings to BAM File" help="If this option is provided, then the quasi-mapping results will be written out in SAM-compatible format.  By default, output will be directed to stdout, but an alternative file name can be provided instead">
                <option value="--writeMappings=./output/samout.sam">Enabled</option>
                <option value="" selected="true">Disabled</option>
            </param>
            <when value="--writeMappings=./output/samout.sam">
                <param argument="--writeQualities" type="boolean" truevalue="--writeQualities" falsevalue="" checked="false" label="Write qualities" help="If this flag is provided, then the output SAM file will contain quality strings as well as read sequences." />
            </when>
            <when value=""/>
        </conditional>
        <param argument="--consistentHits" type="boolean" truevalue="--consistentHits" falsevalue="" checked="false" label="Consistent Hits" help="Force hits gathered during quasi-mapping to be 'consistent' (i.e. co-linear and approximately the right distance apart)."/>
    </xml>
    <xml name="align">
        <param argument="--alignments" name="afile" type="data" format="qname_input_sorted.bam,qname_sorted.bam" label="Alignment file"/>
        <param argument="--ont" type="boolean" truevalue="--ont" falsevalue="" label="Is this Alignment file a Oxford Nanopore Technologies (ONT) dataset ?" help="Select this for both cDNA and direct RNA ONT datasets. Enables an alignment error model designed to work with long-read alignments and disables the length effect in the generative model when computing the conditional probability of observing a fragment given that it arises from a specific transcript. This is because in long-read sequencing, we do not expect to observe (i.e. sequence) multiple fragments from the same molecule, and thus we do not expect the transcript length to directly affect the observed fragment count directly"/>
        <param argument="--targets" name="transcript" type="data" format="fasta,fasta.gz" label="Transcript file"/>
        <expand macro="stranded_se"/>
        <param argument="--discardOrphans" type="boolean" truevalue="--discardOrphans" falsevalue="" checked="false" label="Discard orphans" help="Discard orphan alignments in the input. If this flag is passed, then only paired alignments will be considered toward quantification estimates. The default behavior is to consider orphan alignments if no valid paired mappings exist."/>
        <param argument="--noErrorModel" type="boolean" truevalue="--noErrorModel" falsevalue="" checked="false" label="No Error Model" help="Turn off the alignment error model, which takes into account the the observed frequency of different types of mismatches / indels when computing the likelihood of a given alignment. Turning this off can speed up alignment-based salmon, but can harm quantification accuracy."/>
        <param argument="--numErrorBins" type="integer" value="6" min="0" label="Number of Error Bins" help="The number of bins into which to divideeach read when learning and applying the error model. For example, a value of 10 would mean that effectively, a separate error model is learned and applied to each 10th of the read, whilea value of 3 would mean that a separate error model is applied to the read beginning (first third), middle (second third) and end (final third)."/>
        <param argument="--sampleOut" type="boolean" truevalue="--sampleOut" falsevalue="" checked="false" label="Sample out" help="Write a 'postSample.bam' file in the output directory that will sample the input alignments according to the estimated transcript abundances. If you're going to perform downstream analysis of the alignments with tools which don't, themselves, take fragment assignment ambiguity into account, you should use this output"/>
        <param argument="--sampleUnaligned" type="boolean" truevalue="--sampleUnaligned" falsevalue="" checked="false" label="Sample unaligned" help="In addition to sampling the aligned reads, also write the un-aligned reads to 'postSample.bam'."/>
        <param argument="--gencode" type="boolean" truevalue="--gencode" falsevalue="" checked="false" label="Gencode" help="This flag will expect the input transcript fasta to be in GENCODE format, and will split the transcript name at the first '|' character.  These reduced names will be used in the output and when looking for these transcripts in a gene to transcript GTF."/>
    </xml>
    <xml name="quantboth">
        <param argument="--geneMap" type="data" format="tabular,gff,gtf" optional="true" label="File containing a mapping of transcripts to genes" help="If this file is provided Salmon will output both quant.sf and quant.genes.sf files, where the latter contains aggregated gene-level abundance estimates. The transcript to gene mapping should be provided as either a GTF file, or a in a simple tab-delimited format where each line contains the name of a transcript and the gene to which it belongs separated by a tab."/>
        <param argument="--seqBias" type="boolean" truevalue="--seqBias" falsevalue="" checked="false" label="Perform sequence-specific bias correction"/>
        <param argument="--gcBias" type="boolean" truevalue="--gcBias" falsevalue="" checked="false" label="Perform fragment GC bias correction"/>
        <param argument="--incompatPrior" type="float" min="0" max="1" value="0" help="Sets the prior probability that an alignment that disagrees with the specified library type (orientation and strandedness) results from the true fragment origin. Setting this to 0 specifies that alignments that disagree with the library type should be 'impossible', while setting it to 1 says that alignments that disagree with the library type are no less likely than those that do"/>
        <param argument="--meta" type="boolean" truevalue="--meta" falsevalue="" checked="false" label="Meta" help="If you're using Salmon on a metagenomic dataset, consider setting this flag to disable parts of the abundance estimation model that make less sense for metagenomic data."/>
        <!--Salmon quant advanced options: available to both kinds of quant-->
        <section name="adv" title="Additional Options">
            <param argument="--skipQuant" type="boolean" truevalue="--skipQuant" falsevalue="" checked="false" label="skipQuant" help="Skip performing the actual transcript quantification (including any Gibbs sampling or bootstrapping)."/>
            <param argument="--dumpEq" type="boolean" truevalue="--dumpEq" falsevalue="" checked="false" label="Dump equivalence class counts" help="Dump the equivalence class counts that were computed during quasi-mapping."/>
            <param argument="--dumpEqWeights" type="boolean" truevalue="--dumpEqWeights" falsevalue="" checked="false" label="Dump equivalence class counts including rich weights" help="Includes 'rich' equivlance class weights in the output when equivalence class information is being dumped to file."/>
            <param argument="--minAssignedFrags" type="integer" min="0" value="10" label="Minimum assigned fragments" help="The minimum number of fragments that must be assigned to the transcriptome for quantification to proceed."/>
            <param argument="--biasSpeedSamp" type="integer" value="5" label="The value at which the fragment length PMF is down-sampled when evaluating GC fragment bias." help="Larger values speed up effective length correction, but may decrease the fidelity of bias modeling results."/>
            <param argument="--fldMax" type="integer" min="0" value="1000" label="The maximum fragment length to consider when building the empirical distribution."/>
            <param argument="--fldMean" type="integer" min="0" value="250" label="The mean used in the fragment length distribution prior" help="If single end reads are being used for quantification, or there are an insufficient number of uniquely mapping reads when performing paired-end quantification to estimate the empirical fragment length distribution, then use this value to calculate effective lengths."/>
            <param argument="--fldSD" type="integer" min="0" value="25" label="Standard deviation" help="The standard deviation used in the fragment length distribution prior."/>
            <param argument="--forgettingFactor" type="float" value="0.65000000000000002" label="The forgetting factor used in the online learning schedule." help=" A smaller value results in quicker learning, but higher variance and may be unstable. A larger value results in slower learning but may be more stable.  Value should be in the interval (0.5, 1.0].">
                <validator type="in_range" min="0.5" exclude_max="1"/>
            </param>
            <param argument="--initUniform" type="boolean" truevalue="--initUniform" falsevalue="" checked="false" label="Initialization with uniform parameters" help="initialize the offline inference with uniform parameters, rather than seeding with online parameters." />
            <param argument="--maxReadOcc" type="integer" min="0" value="200" label="Maximal read mapping occurence" help="Reads mapping to more than this many places won't be considered."/>
            <param argument="--noLengthCorrection" type="boolean" truevalue="--noLengthCorrection" falsevalue="" label="No length correction" help="[experimental] : Entirely disables length correction when estimating the abundance of transcripts.  This option can be used with protocols where one expects that fragments derive from their underlying targets without regard to that target's length (e.g. QuantSeq)"/>
            <param argument="--noEffectiveLengthCorrection" type="boolean" truevalue="--noEffectiveLengthCorrection" falsevalue="" checked="false" label="Disable effective length correction" help="Disables effective length correction when computing the probability that a fragment was generated from a transcript. If this flag is passed in, the fragment length distribution is not taken into account when computing this probability."/>
            <param argument="--noFragLengthDist" type="boolean" truevalue="--noFragLengthDist" falsevalue="" checked="false" label="Ignore fragment length distribution" help="[experimental] : Don't consider concordance with the learned fragment length distribution when trying to determine the probability that a fragment has originated from a specified location.  Normally, Fragments with unlikely lengths will be assigned a smaller relative probability than those with more likely lengths. When this flag is passed in, the observed fragment length has no effect on that fragment's a priori probability." />
            <param argument="--noBiasLengthThreshold" type="boolean" truevalue="--noBiasLengthThreshold" falsevalue="" checked="false" label="[experimental] : If this option is enabled, then no (lower) threshold will be set on how short bias correction can make effecctive lengths." help="This can increase the precision of bias correction, but harm robustness. The default correction applies a threshold." />
            <param argument="--numBiasSamples" type="integer" min="0" value="2000000" label="Number of fragment mappings to use when learning the sequence-specific bias model."/>
            <param argument="--numAuxModelSamples" type="integer" min="0" value="5000000" label="The first numAuxModelSamples are used to train the auxiliary model parameters." help="(e.g. fragment length distribution, bias, etc.). After ther first numAuxModelSamples observations the auxiliary model parameters will be assumed to have converged and will be fixed." />
            <param argument="--numPreAuxModelSamples" type="integer" min="0" value="5000" label="The first numPreAuxModelSamples will have their assignment likelihoods and contributions to the transcript abundances computed without applying any auxiliary models." help=" The purpose of ignoring the auxiliary models for the first numPreAuxModelSamples observations is to avoid applying these models before thier parameters have been learned sufficiently well." />
            <param argument="--useEM" type="boolean" truevalue="--useEM" falsevalue="" checked="false" label="Use the traditional EM algorithm for optimization in the batch passes." help=""/>
            <param argument="--rangeFactorizationBins" type="integer" value="4" label="Range of factorization bins" help="Factorizes the likelihood used in quantification by adopting a new notion of equivalence classes based on the conditional probabilities with which fragments are generated from different transcripts. This is a more fine-grained factorization than the normal rich equivalence classes. The default value (0) corresponds to the standard rich equivalence classes, and larger values imply a more fine-grained factorization. If range factorization is enabled, a common value to select for this parameter is 4."/>
            <param argument="--numGibbsSamples" type="integer" min="0" value="0" label="Number of Gibbs sampling rounds to perform." help="" />
            <param argument="--noGammaDraw" type="boolean" truevalue="--noGammaDraw" falsevalue="" checked="false" label="No gamma draw" help="This switch will disable drawing transcript fractions from a Gamma distribution during Gibbs sampling. In this case the sampler does not account for shot-noise, but only assignment ambiguity"/>
            <param argument="--numBootstraps" type="integer" min="0" value="0" label="Number of bootstrap samples to generate. Note: This is mutually exclusive with Gibbs sampling." help="" />
            <param argument="--bootstrapReproject" type="boolean" truevalue="--bootstrapReproject" falsevalue="" checked="false" label="Bootstrap reproject" help="This switch will learn the parameter distribution from the bootstrapped counts for each sample, but will reproject those parameters onto the original equivalence class counts."/>
            <param argument="--thinningFactor" type="integer" min="0" value="16" label="Thinning factor" help="Number of steps to discard for every sample kept from the Gibbs chain. The larger this number, the less chance that subsequent samples are auto-correlated, but the slower sampling becomes."/>
            <param argument="--perTranscriptPrior" type="boolean" truevalue="--perTranscriptPrior" falsevalue="" checked="false" label="The prior will be interpreted as a transcript-level prior." help="either the default or the argument provided via --vbPrior" />
            <param argument="--sigDigits" type="integer" min="0" value="3" label="Significant Digits" help="The number of significant digits to write when outputting the EffectiveLength and NumReads columns."/>
            <param argument="--vbPrior" type="float" value="0.01" label="The prior that will be used in the VBEM algorithm." help="This is interpreted as a per-nucleotide prior, unless the --perTranscriptPrior flag is also given, in which case this is used as a transcript-level prior." />
            <param argument="--writeOrphanLinks" type="boolean" truevalue="--writeOrphanLinks" falsevalue="" checked="false" label="Write orphan links" help="Write the transcripts that are linked by orphaned reads."/>
            <param argument="--writeUnmappedNames" type="boolean" truevalue="--writeUnmappedNames" falsevalue="" checked="false" label="Write the names of un-mapped reads to the file unmapped_names.txt." help=""/>
        </section>
    </xml>
    <xml name="citations">
        <citations>
            <citation type="doi">10.1186/s13059-019-1670-y</citation>
            <citation type="doi">10.1038/nmeth.4197</citation>
        </citations>
    </xml>
    <token name="@bam_sort@"><![CDATA[samtools sort -@ \${GALAXY_SLOTS} --output-fmt=BAM -o ./output/bamout.bam]]></token>
    <token name="@indexing@"><![CDATA[
        mkdir ./index &&
        mkdir ./output &&
        #if $TRANSCRIPTSOURCE_CONDITIONAL.TranscriptSource != "indexed":
            #if $TRANSCRIPTSOURCE_CONDITIONAL.s_index.genome
                cat '${TRANSCRIPTSOURCE_CONDITIONAL.s_index.genome}' | grep "^>" | cut -d " " -f 1 > 'decoys.txt' &&
                sed -i.bak -e 's/>//g' 'decoys.txt' &&
                cat '${TRANSCRIPTSOURCE_CONDITIONAL.s_index.fasta}' '${TRANSCRIPTSOURCE_CONDITIONAL.s_index.genome}' > 'input_index.fasta' &&
            #else
                ln -s '${TRANSCRIPTSOURCE_CONDITIONAL.s_index.fasta}' 'input_index.fasta' &&
            #end if
            salmon --no-version-check index -i ./index
                --kmerLen '${TRANSCRIPTSOURCE_CONDITIONAL.s_index.kmer}'
                --gencode
                --threads "\$SLOTS"
                --transcripts 'input_index.fasta'
                #if $TRANSCRIPTSOURCE_CONDITIONAL.s_index.genome
                    --decoy 'decoys.txt'
                #end if
            &&
            #set $index_path = './index'
        #else
            #set $index_path = $TRANSCRIPTSOURCE_CONDITIONAL.index.fields.path
        #end if
        ]]>
    </token>
    <token name="@salreads@"><![CDATA[
        #set compressed = 'no'
        #if $quant_type.input.single_or_paired.single_or_paired_opts == 'single':
            #if $quant_type.input.single_or_paired.input_singles.ext == 'fasta':
                #set $ext = 'fasta'
            #else:
                #if $quant_type.input.single_or_paired.input_singles.is_of_type("fastqsanger.gz"):
                    #set compressed = 'GZ'
                #else if $quant_type.input.single_or_paired.input_singles.is_of_type("fastqsanger.bz2"):
                    #set compressed = 'BZ2'
                #end if
                #set $ext = 'fastq'
            #end if
            ln -s $quant_type.input.single_or_paired.input_singles ./single.$ext &&
        #else if $quant_type.input.single_or_paired.single_or_paired_opts == 'paired_collection':
            #if $quant_type.input.single_or_paired.input_1.forward.ext == 'fasta':
                #set $ext = 'fasta'
            #else:
                #if $quant_type.input.single_or_paired.input_1.forward.is_of_type("fastqsanger.gz"):
                    #set compressed = 'GZ'
                #else if $quant_type.input.single_or_paired.input_1.forward.is_of_type("fastqsanger.bz2"):
                    #set compressed = 'BZ2'
                #end if
                #set $ext = 'fastq'
            #end if
            ln -s '${quant_type.input.single_or_paired.input_1.forward}' ./mate1.$ext &&
            ln -s '${quant_type.input.single_or_paired.input_1.reverse}' ./mate2.$ext &&
        #end if
        #if $geneMap:
            ln -s '$geneMap' ./geneMap.${geneMap.ext} &&
        #end if

        salmon --no-version-check quant
            --index '$index_path'
            #if $quant_type.input.single_or_paired.single_or_paired_opts == 'single':
                --libType ${quant_type.input.single_or_paired.libtype.strandedness}
                #if $compressed == 'GZ':
                    --unmatedReads <(zcat < ./single.$ext)
                #else if $compressed == 'BZ2':
                    --unmatedReads <(bzcat < ./single.$ext)
                #else:
                    --unmatedReads ./single.$ext
                #end if
            #else:
                --libType
                #if $quant_type.input.single_or_paired.libtype.strandedness == 'A'
                    A
                #else
                    ${quant_type.input.single_or_paired.libtype.orientation}${quant_type.input.single_or_paired.libtype.strandedness}
                #end if
                #if $compressed == 'GZ':
                    --mates1 <(zcat < ./mate1.$ext)
                    --mates2 <(zcat < ./mate2.$ext)
                #else if $compressed == 'BZ2':
                    --mates1 <(bzcat < ./mate1.$ext)
                    --mates2 <(bzcat < ./mate2.$ext)
                #else:
                    --mates1 ./mate1.$ext
                    --mates2 ./mate2.$ext
                #end if
            #end if
            --threads "\$SLOTS"
            ${quant_type.discardOrphansQuasi}
            ${quant_type.validmap.validateMappings}
            #if $quant_type.validmap.validateMappings:
                --minScoreFraction '${quant_type.validmap.minScoreFraction}'
                --ma '${$quant_type.validmap.matchScore}'
                --mp '${$quant_type.validmap.mismatchPenalty}'
                --go '${$quant_type.validmap.gapOpenPenalty}'
                --ge '${$quant_type.validmap.gapExtensionPenalty}'
                ${$quant_type.validmap.mimicBT2}
                ${$quant_type.validmap.mimicStrictBT2}
                ${$quant_type.validmap.hardFilter}
            #end if
            --consensusSlack '${quant_type.consensusSlack}'
            ${quant_type.dovetail}
            ${quant_type.recoverOrphans}
            ${quant_type.bam_options.writeMappings}
            #if $quant_type.bam_options.writeMappings:
                ${quant_type.bam_options.writeQualities}
            #end if
            ${quant_type.consistentHits}
        ]]>
    </token>
    <token name="@salalign@"><![CDATA[
        #if $geneMap:
            ln -s "$geneMap" ./geneMap.${geneMap.ext} &&
        #end if
        salmon --no-version-check quant
        --targets '${quant_type.transcript}'
        --libType '${quant_type.libtype.strandedness}'
        --alignments '${quant_type.afile}'
        $quant_type.ont
        --threads "\$SLOTS"
        ${quant_type.discardOrphans}
        ${quant_type.noErrorModel}
        --numErrorBins '${quant_type.numErrorBins}'
        ${quant_type.sampleOut}
        ${quant_type.sampleUnaligned}
        ${quant_type.gencode}
        ]]>
    </token>
    <token name="@salquant@"><![CDATA[
        #if $geneMap:
            --geneMap ./geneMap.${geneMap.ext}
        #end if

        ##Further basic options##

        ${seqBias}
        ${gcBias}
        --incompatPrior '${incompatPrior}'
        ${meta}

        ##Advanced options##

        ${adv.skipQuant}
        ${adv.dumpEq}
        ${adv.dumpEqWeights}
        --minAssignedFrags '${adv.minAssignedFrags}'
        --biasSpeedSamp '${adv.biasSpeedSamp}'
        --fldMax '${adv.fldMax}'
        --fldMean '${adv.fldMean}'
        --fldSD '${adv.fldSD}'
        --forgettingFactor '${adv.forgettingFactor}'
        ${adv.initUniform}
        #if str($adv.maxReadOcc):
            --maxReadOcc '${adv.maxReadOcc}'
        #end if
        ${adv.noLengthCorrection}
        ${adv.noEffectiveLengthCorrection}
        ${adv.noFragLengthDist}
        ${adv.noBiasLengthThreshold}
        --numBiasSamples '${adv.numBiasSamples}'
        --numAuxModelSamples '${adv.numAuxModelSamples}'
        --numPreAuxModelSamples '${adv.numPreAuxModelSamples}'
        ${adv.useEM}
        --rangeFactorizationBins '${adv.rangeFactorizationBins}'
        --numGibbsSamples '${adv.numGibbsSamples}'
        ${adv.noGammaDraw}
        --numBootstraps '${adv.numBootstraps}'
        ${adv.bootstrapReproject}
        --thinningFactor '${adv.thinningFactor}'
        ${adv.perTranscriptPrior}
        --sigDigits '${adv.sigDigits}'
        --vbPrior '${adv.vbPrior}'
        ${adv.writeOrphanLinks}
        ${adv.writeUnmappedNames}
        -o ./output
        ]]>
    </token>

    <token name="@salmonhelp@"><![CDATA[
        Salmon is a lightweight method for quantifying transcript abundance from RNA–seq reads, combining a dual-phase parallel inference algorithm and feature-rich bias models with an ultra-fast read mapping procedure.

        The salmon package contains 4 tools:

            * Index: creates a salmon index

            * Quant: quantifies a sample (Reads or mapping-based)

            * Alevin: Single-cell analysis

            * Quantmerge: Merges multiple quantifications into a single file

        Galaxy divides these four into three separate tools in the IUC toolshed:

            * Salmon quant

            * Salmon quantmerge

            * Alevin
        ]]>
    </token>
    <token name="@alevinhelp@"><![CDATA[
        Alevin is a tool — integrated with the salmon software — that introduces a family of algorithms for quantification and analysis of 3’ tagged-end single-cell sequencing data. Currently alevin supports the following two major droplet based single-cell protocols:

            * Drop-seq

            * 10x-Chromium v1/2/3

        Alevin works under the same indexing scheme (as salmon) for the reference, and consumes the set of FASTA/Q files(s) containing the Cellular Barcode(CB) + Unique Molecule identifier (UMI) in one read file and the read sequence in the other. Given just the transcriptome and the raw read files, alevin generates a cell-by-gene count matrix (in a fraction of the time compared to other tools).

        Alevin works in two phases. In the first phase it quickly parses the read file containing the CB and UMI information to generate the frequency distribution of all the observed CBs, and creates a lightweight data-structure for fast-look up and correction of the CB. In the second round, alevin utilizes the read-sequences contained in the files to map the reads to the transcriptome, identify potential PCR/sequencing errors in the UMIs, and performs hybrid de-duplication while accounting for UMI collisions. Finally, a post-abundance estimation CB whitelisting procedure is done and a cell-by-gene count matrix is generated.

        For further information regarding the tool and its optional parameters, visit the `Alevin <https://salmon.readthedocs.io/en/latest/alevin.html?highlight=alevin>`__ and `Salmon <https://salmon.readthedocs.io/en/latest/index.html>`__ wikis.
        ]]>
    </token>
</macros>
