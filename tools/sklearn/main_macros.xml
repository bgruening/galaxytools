<macros>
  <token name="@VERSION@">1.0.8.2</token>

  <xml name="python_requirements">
      <requirements>
          <requirement type="package" version="3.6">python</requirement>
          <requirement type="package" version="0.8.1">Galaxy-ML</requirement>
          <yield/>
      </requirements>
  </xml>

  <xml name="macro_stdio">
    <stdio>
        <exit_code range="1:" level="fatal" description="Error occurred. Please check Tool Standard Error"/>
    </stdio>
  </xml>


  <!--Generic interface-->

  <xml name="sl_Conditional" token_train="tabular" token_data="tabular" token_model="txt">
    <conditional name="selected_tasks">
        <param name="selected_task" type="select" label="Select a Classification Task">
            <option value="train" selected="true">Train a model</option>
            <option value="load">Load a model and predict</option>
        </param>
        <when value="load">
            <param name="infile_model" type="data" format="@MODEL@" label="Models" help="Select a model file."/>
            <param name="infile_data" type="data" format="@DATA@" label="Data (tabular)" help="Select the dataset you want to classify."/>
            <param name="header" type="boolean" optional="True" truevalue="booltrue" falsevalue="boolfalse" checked="False" label="Does the dataset contain header:" />
            <conditional name="prediction_options">
                <param name="prediction_option" type="select" label="Select the type of prediction">
                    <option value="predict">Predict class labels</option>
                    <option value="advanced">Include advanced options</option>
                </param>
                <when value="predict">
                </when>
                <when value="advanced">
                </when>
            </conditional>
        </when>
        <when value="train">
            <conditional name="selected_algorithms">
                <yield />
            </conditional>
        </when>
    </conditional>
  </xml>

  <xml name="advanced_section">
    <section name="options" title="Advanced Options" expanded="False">
      <yield />
    </section>
  </xml>


  <!--Generalized Linear Models-->
  <xml name="loss" token_help=" " token_select="false">
    <param argument="loss" type="select" label="Loss function"  help="@HELP@">
        <option value="squared_loss" selected="@SELECT@">squared loss</option>
        <option value="huber">huber</option>
        <option value="epsilon_insensitive">epsilon insensitive</option>
        <option value="squared_epsilon_insensitive">squared epsilon insensitive</option>
        <yield/>
    </param>
  </xml>

  <xml name="penalty" token_help=" ">
    <param argument="penalty" type="select" label="Penalty (regularization term)"  help="@HELP@">
        <option value="l2" selected="true">l2</option>
        <option value="l1">l1</option>
        <option value="elasticnet">elastic net</option>
        <option value="none">none</option>
        <yield/>
    </param>
  </xml>

  <xml name="l1_ratio" token_default_value="0.15" token_help=" ">
    <param argument="l1_ratio" type="float" value="@DEFAULT_VALUE@" label="Elastic Net mixing parameter" help="@HELP@"/>
  </xml>

  <xml name="epsilon" token_default_value="0.1" token_help="Used if loss is ‘huber’, ‘epsilon_insensitive’, or ‘squared_epsilon_insensitive’. ">
    <param argument="epsilon" type="float" value="@DEFAULT_VALUE@" label="Epsilon (epsilon-sensitive loss functions only)" help="@HELP@"/>
  </xml>

  <xml name="learning_rate_s" token_help=" " token_selected1="false" token_selected2="false">
    <param argument="learning_rate" type="select" optional="true" label="Learning rate schedule"  help="@HELP@">
        <option value="optimal" selected="@SELECTED1@">optimal</option>
        <option value="constant">constant</option>
        <option value="invscaling" selected="@SELECTED2@">inverse scaling</option>
        <yield/>
    </param>
  </xml>

  <xml name="eta0" token_default_value="0.0" token_help="Used with ‘constant’ or ‘invscaling’ schedules. ">
    <param argument="eta0" type="float" value="@DEFAULT_VALUE@" label="Initial learning rate" help="@HELP@"/>
  </xml>

  <xml name="power_t" token_default_value="0.5" token_help=" ">
    <param argument="power_t" type="float" value="@DEFAULT_VALUE@" label="Exponent for inverse scaling learning rate" help="@HELP@"/>
  </xml>

  <xml name="normalize" token_checked="false" token_help=" ">
    <param argument="normalize" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="@CHECKED@" label="Normalize samples before training" help=" "/>
  </xml>

  <xml name="copy_X" token_checked="true" token_help=" ">
    <param argument="copy_X" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="@CHECKED@" label="Use a copy of samples" help="If false, samples would be overwritten. "/>
  </xml>

  <xml name="ridge_params">
    <expand macro="normalize"/>
    <expand macro="alpha" default_value="1.0"/>
    <expand macro="fit_intercept"/>
    <expand macro="max_iter" default_value=""/>
    <expand macro="tol" default_value="0.001" help_text="Precision of the solution. "/>
    <!--class_weight-->
    <expand macro="copy_X"/>
    <param argument="solver" type="select" value="" label="Solver to use in the computational routines" help=" ">
        <option value="auto" selected="true">auto</option>
        <option value="svd">svd</option>
        <option value="cholesky">cholesky</option>
        <option value="lsqr">lsqr</option>
        <option value="sparse_cg">sparse_cg</option>
        <option value="sag">sag</option>
    </param>
    <expand macro="random_state"/>
  </xml>

  <!--Ensemble methods-->
  <xml name="n_estimators" token_default_value="10" token_help=" ">
    <param argument="n_estimators" type="integer" optional="true" value="@DEFAULT_VALUE@" label="Number of trees in the forest" help="@HELP@"/>
  </xml>

  <xml name="max_depth" token_default_value="" token_help=" ">
    <param argument="max_depth" type="integer" optional="true" value="@DEFAULT_VALUE@" label="Maximum depth of the tree" help="@HELP@"/>
  </xml>

  <xml name="min_samples_split" token_type="integer" token_default_value="2" token_help=" ">
    <param argument="min_samples_split" type="@TYPE@" optional="true" value="@DEFAULT_VALUE@" label="Minimum number of samples required to split an internal node" help="@HELP@"/>
  </xml>

  <xml name="min_samples_leaf" token_type="integer" token_default_value="1" token_label="Minimum number of samples in newly created leaves" token_help=" ">
    <param argument="min_samples_leaf" type="@TYPE@" optional="true" value="@DEFAULT_VALUE@" label="@LABEL@" help="@HELP@"/>
  </xml>

  <xml name="min_weight_fraction_leaf" token_default_value="0.0" token_help=" ">
    <param argument="min_weight_fraction_leaf" type="float" optional="true" value="@DEFAULT_VALUE@" label="Minimum weighted fraction of the input samples required to be at a leaf node" help="@HELP@"/>
  </xml>

  <xml name="max_leaf_nodes" token_default_value="" token_help=" ">
    <param argument="max_leaf_nodes" type="integer" optional="true" value="@DEFAULT_VALUE@" label="Maximum number of leaf nodes in best-first method" help="@HELP@"/>
  </xml>

  <xml name="min_impurity_decrease" token_default_value="0" token_help=" ">
    <param argument="min_impurity_decrease" type="float" value="@DEFAULT_VALUE@" optional="true" label="The threshold value of impurity for stopping node splitting" help="@HELP@"/>
  </xml>

  <xml name="bootstrap" token_checked="true" token_help=" ">
    <param argument="bootstrap" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolflase" checked="@CHECKED@" label="Use bootstrap samples for building trees." help="@HELP@"/>
  </xml>

  <xml name="criterion" token_help=" ">
    <param argument="criterion" type="select" label="Function to measure the quality of a split"  help=" ">
        <option value="gini" selected="true">Gini impurity</option>
        <option value="entropy">Information gain</option>
        <yield/>
    </param>
  </xml>

  <xml name="criterion2" token_help="">
    <param argument="criterion" type="select" label="Function to measure the quality of a split" >
      <option value="mse">mse - mean squared error</option>
      <option value="mae">mae - mean absolute error</option>
      <yield/>
    </param>
  </xml>

  <xml name="oob_score" token_checked="false" token_help=" ">
    <param argument="oob_score" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="@CHECKED@" label="Use out-of-bag samples to estimate the generalization error" help="@HELP@"/>
  </xml>

  <xml name="max_features">
    <conditional name="select_max_features">
      <param argument="max_features" type="select" label="max_features">
        <option value="auto" selected="true">auto - max_features=n_features</option>
        <option value="sqrt">sqrt - max_features=sqrt(n_features)</option>
        <option value="log2">log2 - max_features=log2(n_features)</option>
        <option value="number_input">I want to type the number in or input None type</option>
      </param>
      <when value="auto">
      </when>
      <when value="sqrt">
      </when>
      <when value="log2">
      </when>
      <when value="number_input">
        <param name="num_max_features" type="float" value="" optional="true" label="Input max_features number:" help="If int, consider the number of features at each split; If float, then max_features is a percentage and int(max_features * n_features) features are considered at each split."/>
      </when>
    </conditional>
  </xml>

  <xml name="verbose" token_default_value="0" token_help="If 1 then it prints progress and performance once in a while. If greater than 1 then it prints progress and performance for every tree.">
    <param argument="verbose" type="integer" value="@DEFAULT_VALUE@" optional="true" label="Enable verbose output" help="@HELP@"/>
  </xml>

  <xml name="learning_rate" token_default_value="1.0" token_help=" ">
    <param argument="learning_rate" type="float" optional="true" value="@DEFAULT_VALUE@" label="Learning rate" help="@HELP@"/>
  </xml>

  <xml name="subsample" token_help=" ">
    <param argument="subsample" type="float" value="1.0" optional="true" label="The fraction of samples to be used for fitting the individual base learners" help="@HELP@"/>
  </xml>

  <xml name="presort">
    <param argument="presort" type="select" label="Whether to presort the data to speed up the finding of best splits in fitting" >
      <option value="auto" selected="true">auto</option>
      <option value="true">true</option>
      <option value="false">false</option>
    </param>
  </xml>

  <!-- LightGBM -->
  <xml name="feature_fraction" token_help="LightGBM will randomly select part of the features for each iteration (tree) if feature_fraction is smaller than 1.0. For example, if you set it to 0.8, LightGBM will select 80% of features before training each tree.">
    <param argument="feature_fraction" type="float" value="1.0" label="Proportion of features to train each tree" help="@HELP@"/>
  </xml>
  
  <xml name="lambda_l1" token_help=" ">
    <param argument="lambda_l1" type="float" value="0.0" label="L1 regularization" help="@HELP@"/>
  </xml>

  <xml name="lambda_l2" token_help=" ">
    <param argument="lambda_l2" type="float" value="0.0" label="L1 regularization" help="@HELP@"/>
  </xml>

  <xml name="min_gain_to_split" token_help=" ">
    <param argument="min_gain_to_split" type="float" value="0.0" label="Minimal gain to perform split" help="@HELP@"/>
  </xml>

  <xml name="min_child_weight" token_help="Minimal sum hessian in one leaf. It can be used to deal with over-fitting.">
    <param argument="min_child_weight" type="float" value="0.0" label="Minimal sum hessian in one leaf" help="@HELP@"/>
  </xml>


  <!--Parameters-->
  <xml name="tol" token_default_value="0.0" token_help_text="Early stopping heuristics based on the relative center changes. Set to default (0.0) to disable this convergence detection.">
        <param argument="tol" type="float" optional="true" value="@DEFAULT_VALUE@" label="Tolerance" help="@HELP_TEXT@"/>
  </xml>

  <xml name="n_clusters" token_default_value="8">
    <param argument="n_clusters" type="integer" optional="true" value="@DEFAULT_VALUE@" label="Number of clusters" help=" "/>
  </xml>

  <xml name="fit_intercept" token_checked="true">
    <param argument="fit_intercept" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="@CHECKED@" label="Estimate the intercept" help="If false, the data is assumed to be already centered."/>
  </xml>

  <xml name="n_iter_no_change" token_default_value="5" token_help_text="Number of iterations with no improvement to wait before early stopping. ">
    <param argument="n_iter_no_change" type="integer" optional="true" value="@DEFAULT_VALUE@" label="Number of iterations" help="@HELP_TEXT@"/>
  </xml>

  <xml name="shuffle" token_checked="true" token_help_text=" " token_label="Shuffle data after each iteration">
    <param argument="shuffle" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="@CHECKED@" label="@LABEL@" help="@HELP_TEXT@"/>
  </xml>

  <xml name="random_state" token_default_value="" token_help_text="Integer number. The seed of the pseudo random number generator to use when shuffling the data. A fixed seed allows reproducible results. default=None.">
    <param argument="random_state" type="integer" optional="true" value="@DEFAULT_VALUE@" label="Random seed number" help="@HELP_TEXT@"/>
  </xml>

  <xml name="warm_start" token_checked="true" token_help_text="When set to True, reuse the solution of the previous call to fit as initialization,otherwise, just erase the previous solution.">
    <param argument="warm_start" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="@CHECKED@" label="Perform warm start" help="@HELP_TEXT@"/>
  </xml>

  <xml name="C" token_default_value="1.0" token_help_text="Penalty parameter C of the error term.">
    <param argument="C" type="float" optional="true" value="@DEFAULT_VALUE@" label="Penalty parameter" help="@HELP_TEXT@"/>
  </xml>

  <!--xml name="class_weight" token_default_value="" token_help_text="">
    <param argument="class_weight" type="" optional="true" value="@DEFAULT_VALUE@" label="" help="@HELP_TEXT@"/>
  </xml-->

  <xml name="alpha" token_default_value="0.0001" token_help_text="Constant that multiplies the regularization term if regularization is used. ">
    <param argument="alpha" type="float" optional="true" value="@DEFAULT_VALUE@" label="Regularization coefficient" help="@HELP_TEXT@"/>
  </xml>

  <xml name="n_samples" token_default_value="100" token_help_text="The total number of points equally divided among clusters.">
    <param argument="n_samples" type="integer" optional="true" value="@DEFAULT_VALUE@" label="Number of samples" help="@HELP_TEXT@"/>
  </xml>

  <xml name="n_features" token_default_value="2" token_help_text="Number of different numerical properties produced for each sample.">
    <param argument="n_features" type="integer" optional="true" value="@DEFAULT_VALUE@" label="Number of features" help="@HELP_TEXT@"/>
  </xml>

  <xml name="noise" token_default_value="0.0" token_help_text="Floating point number. ">
    <param argument="noise" type="float" optional="true" value="@DEFAULT_VALUE@" label="Standard deviation of the Gaussian noise added to the data" help="@HELP_TEXT@"/>
  </xml>

  <xml name="C" token_default_value="1.0" token_help_text="Penalty parameter C of the error term. ">
      <param argument="C" type="float" optional="true" value="@DEFAULT_VALUE@" label="Penalty parameter" help="@HELP_TEXT@"/>
  </xml>

  <xml name="max_iter" token_default_value="300" token_label="Maximum number of iterations per single run" token_help_text=" ">
      <param argument="max_iter" type="integer" optional="true" value="@DEFAULT_VALUE@" label="@LABEL@" help="@HELP_TEXT@"/>
  </xml>

  <xml name="n_init" token_default_value="10" >
      <param argument="n_init" type="integer" optional="true" value="@DEFAULT_VALUE@" label="Number of runs with different centroid seeds" help=" "/>
  </xml>

  <xml name="init">
      <param argument="init" type="select" label="Centroid initialization method"  help="''k-means++'' selects initial cluster centers that speed up convergence. ''random'' chooses k observations (rows) at random from data as initial centroids.">
          <option value="k-means++">k-means++</option>
          <option value="random">random</option>
      </param>
  </xml>

  <xml name="gamma" token_default_value="1.0" token_label="Scaling parameter" token_help_text=" ">
    <param argument="gamma" type="float" optional="true" value="@DEFAULT_VALUE@" label="@LABEL@" help="@HELP_TEXT@"/>
  </xml>

  <xml name="degree" token_default_value="3" token_label="Degree of the polynomial" token_help_text=" ">
    <param argument="degree" type="integer" optional="true" value="@DEFAULT_VALUE@" label="@LABEL@" help="@HELP_TEXT@"/>
  </xml>

  <xml name="coef0" token_default_value="1" token_label="Zero coefficient" token_help_text=" ">
    <param argument="coef0" type="integer" optional="true" value="@DEFAULT_VALUE@" label="@LABEL@" help="@HELP_TEXT@"/>
  </xml>

  <xml name="pos_label" token_default_value="">
    <param argument="pos_label" type="integer" optional="true" value="@DEFAULT_VALUE@" label="Label of the positive class" help=" "/>
  </xml>

  <xml name="average">
    <param argument="average" type="select" optional="true" label="Averaging type" help=" ">
      <option value="micro">Calculate metrics globally by counting the total true positives, false negatives and false positives. (micro)</option>
      <option value="samples">Calculate metrics for each instance, and find their average. Only meaningful for multilabel. (samples)</option>
      <option value="macro">Calculate metrics for each label, and find their unweighted mean. This does not take label imbalance into account. (macro)</option>
      <option value="weighted">Calculate metrics for each label, and find their average, weighted by support (the number of true instances for each label). This alters ‘macro’ to account for label imbalance; it can result in an F-score that is not between precision and recall. (weighted)</option>
      <option value="None">None</option>
      <yield/>
    </param>
  </xml>

  <xml name="beta">
    <param argument="beta" type="float" value="1.0" label="The strength of recall versus precision in the F-score" help=" "/>
  </xml>


  <!--Data interface-->

  <xml name="samples_tabular" token_label1="Training samples dataset:" token_multiple1="false" token_multiple2="false">
    <param name="infile1" type="data" format="tabular" label="@LABEL1@"/>
    <param name="header1" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="False" label="Does the dataset contain header:" />
    <conditional name="column_selector_options_1">
      <expand macro="samples_column_selector_options" multiple="@MULTIPLE1@"/>
    </conditional>
    <param name="infile2" type="data" format="tabular" label="Dataset containing class labels or target values:"/>
    <param name="header2" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="False" label="Does the dataset contain header:" />
    <conditional name="column_selector_options_2">
      <expand macro="samples_column_selector_options" column_option="selected_column_selector_option2" col_name="col2" multiple="@MULTIPLE2@" infile="infile2"/>
    </conditional>
    <yield/>
  </xml>

  <xml name="samples_column_selector_options" token_column_option="selected_column_selector_option" token_col_name="col1" token_multiple="False" token_infile="infile1">
    <param name="@COLUMN_OPTION@" type="select" label="Choose how to select data by column:">
      <option value="by_index_number" selected="true">Select columns by column index number(s)</option>
      <option value="all_but_by_index_number">All columns EXCLUDING some by column index number(s)</option>
      <option value="by_header_name">Select columns by column header name(s)</option>
      <option value="all_but_by_header_name">All columns EXCLUDING some by column header name(s)</option>
      <option value="all_columns">All columns</option>
    </param>
    <when value="by_index_number">
      <param name="@COL_NAME@" multiple="@MULTIPLE@" type="data_column" use_header_names="true" data_ref="@INFILE@" label="Select target column(s):"/>
    </when>
    <when value="all_but_by_index_number">
      <param name="@COL_NAME@" multiple="@MULTIPLE@" type="data_column" use_header_names="true" data_ref="@INFILE@" label="Select target column(s):"/>
    </when>
    <when value="by_header_name">
      <param name="@COL_NAME@" type="text" value="" label="Type header name(s):" help="Comma-separated string. For example: target1,target2"/>
    </when>
    <when value="all_but_by_header_name">
      <param name="@COL_NAME@" type="text" value="" label="Type header name(s):" help="Comma-separated string. For example: target1,target2"/>
    </when>
    <when value="all_columns">
    </when>
  </xml>

  <xml name="clf_inputs_extended" token_label1=" " token_label2=" " token_multiple="False">
    <conditional name="true_columns">
      <param name="selected_input1" type="select" label="Select the input type of true labels dataset:">
          <option value="tabular" selected="true">Tabular</option>
          <option value="sparse">Sparse</option>
      </param>
      <when value="tabular">
        <param name="infile1" type="data" label="@LABEL1@"/>
        <param name="col1" type="data_column" data_ref="infile1" label="Select the target column:"/>
      </when>
      <when value="sparse">
          <param name="infile1" type="data" format="txt" label="@LABEL1@"/>
      </when>
    </conditional>
    <conditional name="predicted_columns">
      <param name="selected_input2" type="select" label="Select the input type of predicted labels dataset:">
          <option value="tabular" selected="true">Tabular</option>
          <option value="sparse">Sparse</option>
      </param>
      <when value="tabular">
        <param name="infile2" type="data" label="@LABEL2@"/>
        <param name="col2" multiple="@MULTIPLE@" type="data_column" data_ref="infile2" label="Select target column(s):"/>
      </when>
      <when value="sparse">
          <param name="infile2" type="data" format="txt" label="@LABEL1@"/>
      </when>
    </conditional>
  </xml>

  <xml name="clf_inputs" token_label1="Dataset containing true labels (tabular):" token_label2="Dataset containing predicted values (tabular):" token_multiple1="False" token_multiple="False">
    <param name="infile1" type="data" format="tabular" label="@LABEL1@"/>
    <param name="header1" type="boolean" optional="True" truevalue="booltrue" falsevalue="boolfalse" checked="False" label="Does the dataset contain header:" />
    <conditional name="column_selector_options_1">
      <expand macro="samples_column_selector_options" multiple="@MULTIPLE1@"/>
    </conditional>
    <param name="infile2" type="data" format="tabular" label="@LABEL2@"/>
    <param name="header2" type="boolean" optional="True" truevalue="booltrue" falsevalue="boolfalse" checked="False" label="Does the dataset contain header:" />
    <conditional name="column_selector_options_2">
      <expand macro="samples_column_selector_options" column_option="selected_column_selector_option2" col_name="col2" multiple="@MULTIPLE@" infile="infile2"/>
    </conditional>
  </xml>

  <xml name="multiple_input" token_name="input_files" token_max_num="10" token_format="txt" token_label="Sparse matrix file (.mtx, .txt)" token_help_text="Specify a sparse matrix file in .txt format.">
    <repeat name="@NAME@" min="1" max="@MAX_NUM@" title="Select input file(s):">
        <param name="input" type="data" format="@FORMAT@" label="@LABEL@" help="@HELP_TEXT@"/>
    </repeat>
  </xml>

  <xml name="sparse_target" token_label1="Select a sparse matrix:" token_label2="Select the tabular containing true labels:" token_multiple="False" token_format1="txt" token_format2="tabular" token_help1="" token_help2="">
    <param name="infile1" type="data" format="@FORMAT1@" label="@LABEL1@" help="@HELP1@"/>
    <expand macro="input_tabular_target"/>
  </xml>

  <xml name="sl_mixed_input">
    <conditional name="input_options">
        <expand macro="data_input_options"/>
        <expand macro="data_input_whens"/>
    </conditional>
  </xml>

  <xml name="sl_mixed_input_plus_sequence">
    <conditional name="input_options">
        <expand macro="data_input_options">
            <option value="seq_fasta">sequnences in a fasta file</option>
            <option value="refseq_and_interval">reference genome and intervals</option>
        </expand>
        <expand macro="data_input_whens">
            <when value="seq_fasta">
                <expand macro="inputs_seq_fasta"/>
            </when>
            <when value="refseq_and_interval">
                <expand macro="inputs_refseq_and_interval"/>
            </when>
        </expand>
    </conditional>
  </xml>

  <xml name="data_input_options">
    <param name="selected_input" type="select" label="Select input type:">
        <option value="tabular" selected="true">tabular data</option>
        <option value="sparse">sparse matrix</option>
        <yield/>
    </param>
  </xml>

  <xml name="data_input_whens">
    <when value="tabular">
        <expand macro="samples_tabular" multiple1="true" multiple2="false"/>
    </when>
    <when value="sparse">
        <expand macro="sparse_target"/>
    </when>
    <yield/>
  </xml>

  <xml name="input_tabular_target">
    <param name="infile2" type="data" format="tabular" label="Dataset containing class labels or target values:"/>
    <param name="header2" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="false" label="Does the dataset contain header:" />
    <conditional name="column_selector_options_2">
      <expand macro="samples_column_selector_options" column_option="selected_column_selector_option2" col_name="col2" multiple="false" infile="infile2"/>
    </conditional>
  </xml>

  <xml name="inputs_seq_fasta">
    <param name="fasta_path" type="data" format="fasta" label="Dataset containing fasta genomic/protein sequences" help="Sequences will be one-hot encoded to arrays."/>
    <expand macro="input_tabular_target"/>
  </xml>

  <xml name="inputs_refseq_and_interval">
    <param name="ref_genome_file" type="data" format="fasta" label="Dataset containing reference genomic sequence"/>
    <param name="interval_file" type="data" format="interval" label="Dataset containing sequence intervals for training" help="interval. Sequences will be retrieved from the reference genome and one-hot encoded to training arrays."/>
    <param name="target_file" type="data" format="bed" label="Dataset containing positions and features for target values." help="bed. The file will be compressed with `bgzip` and then indexed using `tabix`."/>
    <param name="infile2" type="data" format="tabular" label="Dataset containing the feature list for prediction"/>
    <param name="header2" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="false" label="Does the dataset contain header:" />
    <conditional name="column_selector_options_2">
      <expand macro="samples_column_selector_options" column_option="selected_column_selector_option2" col_name="col2" multiple="true" infile="infile2"/>
    </conditional>
  </xml>

  <!--Advanced options-->
  <xml name="nn_advanced_options">
    <section name="options" title="Advanced Options" expanded="False">
      <yield/>
      <param argument="weights" type="select" label="Weight function" help="Used in prediction.">
          <option value="uniform" selected="true">Uniform weights. All points in each neighborhood are weighted equally. (Uniform)</option>
          <option value="distance">Weight points by the inverse of their distance. (Distance)</option>
      </param>
      <param argument="algorithm" type="select" label="Neighbor selection algorithm" help=" ">
          <option value="auto" selected="true">Auto</option>
          <option value="ball_tree">BallTree</option>
          <option value="kd_tree">KDTree</option>
          <option value="brute">Brute-force</option>
      </param>
      <param argument="leaf_size" type="integer" value="30" label="Leaf size" help="Used with BallTree and KDTree. Affects the time and memory usage of the constructed tree."/>
      <!--param name="metric"-->
      <!--param name="p"-->
      <!--param name="metric_params"-->
    </section>
  </xml>

  <xml name="svc_advanced_options">
    <section name="options" title="Advanced Options" expanded="False">
        <yield/>
        <param argument="kernel" type="select" optional="true" label="Kernel type" help="Kernel type to be used in the algorithm. If none is given, ‘rbf’ will be used.">
            <option value="rbf" selected="true">rbf</option>
            <option value="linear">linear</option>
            <option value="poly">poly</option>
            <option value="sigmoid">sigmoid</option>
            <option value="precomputed">precomputed</option>
        </param>
        <param argument="degree" type="integer" optional="true" value="3" label="Degree of the polynomial (polynomial kernel only)" help="Ignored by other kernels. dafault : 3 "/>
        <!--TODO: param argument="gamma" float, optional (default=’auto’) -->
        <param argument="coef0" type="float" optional="true" value="0.0" label="Zero coefficient (polynomial and sigmoid kernels only)"
            help="Independent term in kernel function. dafault: 0.0 "/>
        <param argument="shrinking" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="true"
            label="Use the shrinking heuristic" help=" "/>
        <param argument="probability" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="false"
            label="Enable probability estimates. " help="This must be enabled prior to calling fit, and will slow down that method."/>
        <!-- param argument="cache_size"-->
        <!--expand macro="class_weight"/-->
        <expand macro="tol" default_value="0.001" help_text="Tolerance for stopping criterion. "/>
        <expand macro="max_iter" default_value="-1" label="Solver maximum number of iterations" help_text="Hard limit on iterations within solver, or -1 for no limit."/>
        <!--param argument="decision_function_shape"-->
        <expand macro="random_state" help_text="Integer number. The seed of the pseudo random number generator to use when shuffling the data for probability estimation. A fixed seed allows reproducible results."/>
    </section>
  </xml>

  <xml name="spectral_clustering_advanced_options">
    <section name="options" title="Advanced Options" expanded="False">
        <expand macro="n_clusters"/>
        <param argument="eigen_solver" type="select" value="" label="Eigen solver" help="The eigenvalue decomposition strategy to use.">
            <option value="arpack" selected="true">arpack</option>
            <option value="lobpcg">lobpcg</option>
            <option value="amg">amg</option>
            <!--None-->
        </param>
        <expand macro="random_state"/>
        <expand macro="n_init"/>
        <param argument="gamma" type="float" optional="true" value="1.0" label="Kernel scaling factor" help="Scaling factor of RBF, polynomial, exponential chi^2 and sigmoid affinity kernel. Ignored for affinity=''nearest_neighbors''."/>
        <param argument="affinity" type="select" label="Affinity" help="Affinity kernel to use. ">
            <option value="rbf" selected="true">RBF</option>
            <option value="precomputed">precomputed</option>
            <option value="nearest_neighbors">Nearset neighbors</option>
        </param>
        <param argument="n_neighbors" type="integer" optional="true" value="10" label="Number of neighbors" help="Number of neighbors to use when constructing the affinity matrix using the nearest neighbors method. Ignored for affinity=''rbf''"/>
        <!--param argument="eigen_tol"-->
        <param argument="assign_labels" type="select" label="Assign labels" help="The strategy to use to assign labels in the embedding space.">
            <option value="kmeans" selected="true">kmeans</option>
            <option value="discretize">discretize</option>
        </param>
        <param argument="degree" type="integer" optional="true" value="3"
            label="Degree of the polynomial (polynomial kernel only)" help="Ignored by other kernels. dafault : 3 "/>
        <param argument="coef0" type="integer" optional="true" value="1"
            label="Zero coefficient (polynomial and sigmoid kernels only)" help="Ignored by other kernels. dafault : 1 "/>
        <!--param argument="kernel_params"-->
    </section>
  </xml>

  <xml name="minibatch_kmeans_advanced_options">
    <section name="options" title="Advanced Options" expanded="False">
        <expand macro="n_clusters"/>
        <expand macro="init"/>
        <expand macro="n_init" default_value="3"/>
        <expand macro="max_iter" default_value="100"/>
        <expand macro="tol" help_text="Early stopping heuristics based on normalized center change. To disable set to 0.0 ."/>
        <expand macro="random_state"/>
        <param argument="batch_size" type="integer" optional="true" value="100" label="Batch size" help="Size of the mini batches."/>
        <!--param argument="compute_labels"-->
        <param argument="max_no_improvement" type="integer" optional="true" value="10" label="Maximum number of improvement attempts" help="
        Convergence detection based on inertia (the consecutive number of mini batches that doe not yield an improvement on the smoothed inertia).
        To disable, set max_no_improvement to None. "/>
        <param argument="init_size" type="integer" optional="true" value="" label="Number of random initialization samples" help="Number of samples to randomly sample for speeding up the initialization . ( default: 3 * batch_size )"/>
        <param argument="reassignment_ratio" type="float" optional="true" value="0.01" label="Re-assignment ratio" help="Controls the fraction of the maximum number of counts for a center to be reassigned. Higher values yield better clustering results."/>
    </section>
  </xml>

  <xml name="kmeans_advanced_options">
    <section name="options" title="Advanced Options" expanded="False">
      <expand macro="n_clusters"/>
      <expand macro="init"/>
      <expand macro="n_init"/>
      <expand macro="max_iter"/>
      <expand macro="tol" default_value="0.0001" help_text="Relative tolerance with regards to inertia to declare convergence."/>
      <!--param argument="precompute_distances"/-->
      <expand macro="random_state"/>
      <param argument="copy_x" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="true" label="Use a copy of data for precomputing distances" help="Mofifying the original data introduces small numerical differences caused by subtracting and then adding the data mean."/>
      <expand macro="kmeans_algorithm"/>
    </section>
  </xml>

  <xml name="kmeans_algorithm">
    <param argument="algorithm" type="select" label="K-means algorithm to use:">
      <option value="auto" selected="true">auto</option>
      <option value="full">full</option>
      <option value="elkan">elkan</option>
    </param>
  </xml>

  <xml name="birch_advanced_options">
    <section name="options" title="Advanced Options" expanded="False">
      <param argument="threshold" type="float" optional="true" value="0.5" label="Subcluster radius threshold" help="The radius of the subcluster obtained by merging a new sample; the closest subcluster should be less than the threshold to avoid a new subcluster."/>
      <param argument="branching_factor" type="integer" optional="true" value="50" label="Maximum number of subclusters per branch" help="Maximum number of CF subclusters in each node."/>
      <expand macro="n_clusters" default_value="3"/>
      <!--param argument="compute_labels"/-->
    </section>
  </xml>

  <xml name="dbscan_advanced_options">
    <section name="options" title="Advanced Options" expanded="False">
      <param argument="eps" type="float" optional="true" value="0.5" label="Maximum neighborhood distance" help="The maximum distance between two samples for them to be considered as in the same neighborhood."/>
      <param argument="min_samples" type="integer" optional="true" value="5" label="Minimal core point density" help="The number of samples (or total weight) in a neighborhood for a point (including the point itself) to be considered as a core point."/>
      <param argument="metric" type="text" optional="true" value="euclidean" label="Metric" help="The metric to use when calculating distance between instances in a feature array."/>
      <param argument="algorithm" type="select" label="Pointwise distance computation algorithm" help="The algorithm to be used by the NearestNeighbors module to compute pointwise distances and find nearest neighbors.">
          <option value="auto" selected="true">auto</option>
          <option value="ball_tree">ball_tree</option>
          <option value="kd_tree">kd_tree</option>
          <option value="brute">brute</option>
      </param>
      <param argument="leaf_size" type="integer" optional="true" value="30" label="Leaf size" help="Leaf size passed to BallTree or cKDTree. Memory and time efficieny factor in tree constrution and querying."/>
    </section>
  </xml>

  <xml name="clustering_algorithms_options">
    <conditional name="algorithm_options">
      <param name="selected_algorithm" type="select" label="Clustering Algorithm">
          <option value="KMeans" selected="true">KMeans</option>
          <option value="SpectralClustering">Spectral Clustering</option>
          <option value="MiniBatchKMeans">Mini Batch KMeans</option>
          <option value="DBSCAN">DBSCAN</option>
          <option value="Birch">Birch</option>
      </param>
      <when value="KMeans">
          <expand macro="kmeans_advanced_options"/>
      </when>
      <when value="DBSCAN">
          <expand macro="dbscan_advanced_options"/>
      </when>
      <when value="Birch">
          <expand macro="birch_advanced_options"/>
      </when>
      <when value="SpectralClustering">
          <expand macro="spectral_clustering_advanced_options"/>
      </when>
      <when value="MiniBatchKMeans">
          <expand macro="minibatch_kmeans_advanced_options"/>
      </when>
    </conditional>
  </xml>

  <xml name="distance_metrics">
    <param argument="metric" type="select" label="Distance metric" help=" ">
      <option value="euclidean" selected="true">euclidean</option>
      <option value="cityblock">cityblock</option>
      <option value="cosine">cosine</option>
      <option value="l1">l1</option>
      <option value="l2">l2</option>
      <option value="manhattan">manhattan</option>
      <yield/>
    </param>
  </xml>

  <xml name="distance_nonsparse_metrics">
    <option value="braycurtis">braycurtis</option>
    <option value="canberra">canberra</option>
    <option value="chebyshev">chebyshev</option>
    <option value="correlation">correlation</option>
    <option value="dice">dice</option>
    <option value="hamming">hamming</option>
    <option value="jaccard">jaccard</option>
    <option value="kulsinski">kulsinski</option>
    <option value="mahalanobis">mahalanobis</option>
    <option value="matching">matching</option>
    <option value="minkowski">minkowski</option>
    <option value="rogerstanimoto">rogerstanimoto</option>
    <option value="russellrao">russellrao</option>
    <option value="seuclidean">seuclidean</option>
    <option value="sokalmichener">sokalmichener</option>
    <option value="sokalsneath">sokalsneath</option>
    <option value="sqeuclidean">sqeuclidean</option>
    <option value="yule">yule</option>
  </xml>

  <xml name="pairwise_kernel_metrics">
    <param argument="metric" type="select" label="Pirwise Kernel metric" help=" ">
      <option value="rbf" selected="true">rbf</option>
      <option value="sigmoid">sigmoid</option>
      <option value="polynomial">polynomial</option>
      <option value="linear" selected="true">linear</option>
      <option value="chi2">chi2</option>
      <option value="additive_chi2">additive_chi2</option>
    </param>
  </xml>

  <xml name="sparse_pairwise_metric_functions">
    <param name="selected_metric_function" type="select" label="Select the pairwise metric you want to compute:">
      <option value="euclidean_distances" selected="true">Euclidean distance matrix</option>
      <option value="pairwise_distances">Distance matrix</option>
      <option value="pairwise_distances_argmin">Minimum distances between one point and a set of points</option>
      <yield/>
    </param>
  </xml>

  <xml name="pairwise_metric_functions">
    <option value="additive_chi2_kernel" >Additive chi-squared kernel</option>
    <option value="chi2_kernel">Exponential chi-squared kernel</option>
    <option value="linear_kernel">Linear kernel</option>
    <option value="manhattan_distances">L1 distances</option>
    <option value="pairwise_kernels">Kernel</option>
    <option value="polynomial_kernel">Polynomial kernel</option>
    <option value="rbf_kernel">Gaussian (rbf) kernel</option>
    <option value="laplacian_kernel">Laplacian kernel</option>
  </xml>

  <xml name="sparse_pairwise_condition">
    <when value="pairwise_distances">
      <section name="options" title="Advanced Options" expanded="False">
          <expand macro="distance_metrics">
              <yield/>
          </expand>
      </section>
    </when>
    <when value="euclidean_distances">
      <section name="options" title="Advanced Options" expanded="False">
          <param argument="squared" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="false"
            label="Return squared Euclidean distances" help=" "/>
      </section>
    </when>
  </xml>

  <xml name="argmin_distance_condition">
    <when value="pairwise_distances_argmin">
      <section name="options" title="Advanced Options" expanded="False">
          <param argument="axis" type="integer" optional="true" value="1" label="Axis" help="Axis along which the argmin and distances are to be computed."/>
          <expand macro="distance_metrics">
              <yield/>
          </expand>
          <param argument="batch_size" type="integer" optional="true" value="500" label="Batch size" help="Number of rows to be processed in each batch run."/>
      </section>
    </when>
  </xml>

  <xml name="sparse_preprocessors">
    <param name="selected_pre_processor" type="select" label="Select a preprocessor:">
      <option value="StandardScaler" selected="true">Standard Scaler (Standardizes features by removing the mean and scaling to unit variance)</option>
      <option value="Binarizer">Binarizer (Binarizes data)</option>
      <option value="MaxAbsScaler">Max Abs Scaler (Scales features by their maximum absolute value)</option>
      <option value="Normalizer">Normalizer (Normalizes samples individually to unit norm)</option>
      <yield/>
    </param>
  </xml>

  <xml name="sparse_preprocessors_ext">
    <expand macro="sparse_preprocessors">
      <option value="KernelCenterer">Kernel Centerer (Centers a kernel matrix)</option>
      <option value="MinMaxScaler">Minmax Scaler (Scales features to a range)</option>
      <option value="PolynomialFeatures">Polynomial Features (Generates polynomial and interaction features)</option>
      <option value="RobustScaler">Robust Scaler (Scales features using outlier-invariance statistics)</option>
      <option value="QuantileTransformer">QuantileTransformer (Transform features using quantiles information)</option>
      <option value="PowerTransformer">PowerTransformer (Apply a power transform featurewise to make data more Gaussian-like)</option>
      <option value="KBinsDiscretizer">KBinsDiscretizer (Bin continuous data into intervals.)</option>
    </expand>
  </xml>

  <xml name="sparse_preprocessor_options">
    <when value="Binarizer">
        <section name="options" title="Advanced Options" expanded="False">
            <param argument="copy" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="true"
                label="Use a copy of data for precomputing binarization" help=" "/>
            <param argument="threshold" type="float" optional="true" value="0.0"
                label="Threshold"
                help="Feature values below or equal to this are replaced by 0, above it by 1. Threshold may not be less than 0 for operations on sparse matrices. "/>
        </section>
    </when>
    <when value="StandardScaler">
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="copy" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="true"
            label="Use a copy of data for performing inplace scaling" help=" "/>
        <param argument="with_mean" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="true"
            label="Center the data before scaling" help=" "/>
        <param argument="with_std" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="true"
            label="Scale the data to unit variance (or unit standard deviation)" help=" "/>
      </section>
    </when>
    <when value="MaxAbsScaler">
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="copy" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="true"
            label="Use a copy of data for precomputing scaling" help=" "/>
      </section>
    </when>
    <when value="Normalizer">
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="norm" type="select" optional="true" label="The norm to use to normalize non zero samples" help=" ">
          <option value="l1" selected="true">l1</option>
          <option value="l2">l2</option>
          <option value="max">max</option>
        </param>
        <param argument="copy" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="true"
            label="Use a copy of data for precomputing row normalization" help=" "/>
      </section>
    </when>
    <yield/>
  </xml>

  <xml name="sparse_preprocessor_options_ext">
    <expand macro="sparse_preprocessor_options">
      <when value="KernelCenterer">
        <section name="options" title="Advanced Options" expanded="False">
        </section>
      </when>
      <when value="MinMaxScaler">
          <section name="options" title="Advanced Options" expanded="False">
              <param argument="feature_range" type="text" value="(0, 1)" optional="true" help="Desired range of transformed data. None or tuple (min, max). None equals to (0, 1)"/>
              <param argument="copy" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolflase" checked="true"
                  label="Use a copy of data for precomputing normalization" help=" "/>
          </section>
      </when>
      <when value="PolynomialFeatures">
          <section name="options" title="Advanced Options" expanded="False">
              <param argument="degree" type="integer" optional="true" value="2" label="The degree of the polynomial features " help=""/>
              <param argument="interaction_only" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolflase" checked="false" label="Produce interaction features only" help="(Features that are products of at most degree distinct input features) "/>
              <param argument="include_bias" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolflase" checked="true" label="Include a bias column" help="Feature in which all polynomial powers are zero "/>
          </section>
      </when>
      <when value="RobustScaler">
          <section name="options" title="Advanced Options" expanded="False">
              <!--=True, =True, copy=True-->
              <param argument="with_centering" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolflase" checked="true"
                  label="Center the data before scaling" help=" "/>
              <param argument="with_scaling" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolflase" checked="true"
                  label="Scale the data to interquartile range" help=" "/>
              <param argument="copy" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolflase" checked="true"
                  label="Use a copy of data for inplace scaling" help=" "/>
          </section>
      </when>
      <when value="QuantileTransformer">
          <section name="options" title="Advanced Options" expanded="False">
              <param name="n_quantiles" type="integer" value="1000" min="0" label="Number of quantiles to be computed" />
              <param name="output_distribution" type="select" label="Marginal distribution for the transformed data">
                  <option value="uniform" selected="true">uniform</option>
                  <option value="normal">normal</option>
              </param>
              <param name="ignore_implicit_zeros" type="boolean" truevalue="booltrue" falsevalue="boolfalse" checked="false" label="Whether to discard sparse entries" help="Only applies to sparse matrices. If False, sparse entries are treated as zeros"/>
              <param name="subsample" type="integer" value="100000" label="Maximum number of samples used to estimate the quantiles for computational efficiency" help="Note that the subsampling procedure may differ for value-identical sparse and dense matrices."/>
              <expand macro="random_state" help_text="This is used by subsampling and smoothing noise"/>
          </section>
      </when>
      <when value="PowerTransformer">
          <section name="options" title="Advanced Options" expanded="False">
              <param name="method" type="select" label="The power transform method">
                  <option value="yeo-johnson" selected="true">yeo-johnson (works with positive and negative values)</option>
                  <option value="box-cox">box-cox (might perform better, but only works with strictly positive values)</option>
              </param>
              <param name="standardize" type="boolean" truevalue="booltrue" falsevalue="boolfalse" checked="true" label="Whether to apply zero-mean, unit-variance normalization to the transformed output."/>
          </section>
      </when>
      <when value="KBinsDiscretizer">
          <section name="options" title="Advanced Options" expanded="False">
              <param name="n_bins" type="integer" value="5" min="2" label="The number of bins to produce"/>
              <param name="encode" type="select" label="Method used to encode the transformed result">
                  <option value="onehot" selected="true">onehot (encode the transformed result with one-hot encoding and return a sparse matrix)</option>
                  <option value="onehot-dense">onehot-dense (encode the transformed result with one-hot encoding and return a dense array)</option>
                  <option value="ordinal">ordinal (return the bin identifier encoded as an integer value)</option>
              </param>
              <param name="strategy" type="select" label="Strategy used to define the widths of the bins">
                  <option value="uniform">uniform (all bins in each feature have identical widths)</option>
                  <option value="quantile" selected="true">quantile (all bins in each feature have the same number of points)</option>
                  <option value="kmeans">kmeans (values in each bin have the same nearest center of a 1D k-means cluster)</option>
              </param>
          </section>
      </when>
    </expand>
  </xml>

  <xml name="cv_splitter">
    <option value="default" selected="true">default splitter</option>
    <option value="KFold">KFold</option>
    <option value="StratifiedKFold">StratifiedKFold</option>
    <option value="LeaveOneOut">LeaveOneOut</option>
    <option value="LeavePOut">LeavePOut</option>
    <option value="RepeatedKFold">RepeatedKFold</option>
    <option value="RepeatedStratifiedKFold">RepeatedStratifiedKFold</option>
    <option value="ShuffleSplit">ShuffleSplit</option>
    <option value="StratifiedShuffleSplit">StratifiedShuffleSplit</option>
    <option value="TimeSeriesSplit">TimeSeriesSplit</option>
    <option value="PredefinedSplit">PredefinedSplit</option>
    <option value="OrderedKFold">OrderedKFold</option>
    <option value="RepeatedOrderedKFold">RepeatedOrderedKFold</option>
    <yield/>
  </xml>

  <xml name="cv_splitter_options">
    <when value="default">
      <expand macro="cv_n_splits"/>
    </when>
    <when value="KFold">
      <expand macro="cv_n_splits"/>
      <expand macro="cv_shuffle"/>
      <expand macro="random_state"/>
    </when>
    <when value="StratifiedKFold">
      <expand macro="cv_n_splits"/>
      <expand macro="cv_shuffle"/>
      <expand macro="random_state"/>
    </when>
    <when value="LeaveOneOut">
    </when>
    <when value="LeavePOut">
      <param argument="p" type="integer" value="" label="p" help="Integer. Size of the test sets."/>
    </when>
    <when value="RepeatedKFold">
      <expand macro="cv_n_splits" value="5"/>
      <param argument="n_repeats" type="integer" value="10" label="n_repeats" help="Number of times cross-validator needs to be repeated." />
      <expand macro="random_state" />
    </when>
    <when value="RepeatedStratifiedKFold">
      <expand macro="cv_n_splits" value="5"/>
      <param argument="n_repeats" type="integer" value="10" label="n_repeats" help="Number of times cross-validator needs to be repeated." />
      <expand macro="random_state" />
    </when>
    <when value="ShuffleSplit">
      <expand macro="cv_n_splits" value="10" help="Number of re-shuffling and splitting iterations."/>
      <expand macro="cv_test_size" value="0.1" />
      <expand macro="random_state"/>
    </when>
    <when value="StratifiedShuffleSplit">
      <expand macro="cv_n_splits" value="10" help="Number of re-shuffling and splitting iterations."/>
      <expand macro="cv_test_size" value="0.1" />
      <expand macro="random_state"/>
    </when>
    <when value="TimeSeriesSplit">
      <expand macro="cv_n_splits"/>
      <param argument="max_train_size" type="integer" value="" optional="true" label="Maximum size of the training set" help="Maximum size for a single training set." />
    </when>
    <when value="PredefinedSplit">
      <param argument="test_fold" type="text" value="" area="true" label="test_fold" help="List, e.g., [0, 1, -1, 1], represents two test sets, [X[0]] and [X[1], X[3]], X[2] is excluded from any test set due to '-1'."/>
    </when>
    <when value="OrderedKFold">
      <expand macro="cv_n_splits"/>
      <expand macro="cv_shuffle"/>
      <expand macro="random_state"/>
    </when>
    <when value="RepeatedOrderedKFold">
      <expand macro="cv_n_splits"/>
      <param argument="n_repeats" type="integer" value="5"/>
      <expand macro="random_state"/>
    </when>
    <yield/>
  </xml>

  <xml name="cv">
    <conditional name="cv_selector">
      <param name="selected_cv" type="select" label="Select the cv splitter:">
        <expand macro="cv_splitter">
          <option value="GroupKFold">GroupKFold</option>
          <option value="GroupShuffleSplit">GroupShuffleSplit</option>
          <option value="LeaveOneGroupOut">LeaveOneGroupOut</option>
          <option value="LeavePGroupsOut">LeavePGroupsOut</option>
        </expand>
      </param>
      <expand macro="cv_splitter_options">
        <when value="GroupKFold">
          <expand macro="cv_n_splits"/>
          <expand macro="cv_groups" />
        </when>
        <when value="GroupShuffleSplit">
          <expand macro="cv_n_splits" value="5"/>
          <expand macro="cv_test_size"/>
          <expand macro="random_state"/>
          <expand macro="cv_groups"/>
        </when>
        <when value="LeaveOneGroupOut">
          <expand macro="cv_groups"/>
        </when>
        <when value="LeavePGroupsOut">
          <param argument="n_groups" type="integer" value="" label="n_groups" help="Number of groups (p) to leave out in the test split." />
          <expand macro="cv_groups"/>
        </when>
      </expand>
    </conditional>
  </xml>

  <xml name="cv_reduced" token_label="Select the cv splitter">
    <conditional name="cv_selector">
      <param name="selected_cv" type="select" label="@LABEL@">
        <expand macro="cv_splitter"/>
      </param>
      <expand macro="cv_splitter_options"/>
    </conditional>
  </xml>

  <xml name="cv_n_splits" token_value="3" token_help="Number of folds. Must be at least 2.">
    <param argument="n_splits" type="integer" value="@VALUE@" min="1" label="n_splits" help="@HELP@"/>
  </xml>

  <xml name="cv_shuffle">
    <param argument="shuffle" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="false" label="Whether to shuffle data before splitting" />
  </xml>

  <xml name="cv_test_size" token_value="0.2">
    <param argument="test_size" type="float" value="@VALUE@" min="0.0" label="Portion or number of the test set" help="0.0-1.0, proportion of the dataset to include in the test split; >1, integer only, the absolute number of test samples "/>
  </xml>

  <xml name="cv_groups" >
    <section name="groups_selector" title="Groups column selector" expanded="true">
      <param name="infile_g" type="data" format="tabular" label="Choose dataset containing groups info:"/>
      <param name="header_g" type="boolean" optional="true" truevalue="booltrue" falsevalue="boolfalse" checked="False" label="Does the dataset contain header:" />
      <conditional name="column_selector_options_g">
        <expand macro="samples_column_selector_options" column_option="selected_column_selector_option_g" col_name="col_g" multiple="False" infile="infile_g"/>
      </conditional>
    </section>
  </xml>

  <xml name="train_test_split_params">
    <conditional name="split_algos">
      <param name="shuffle" type="select" label="Select the splitting method">
        <option value="None">No shuffle</option>
        <option value="simple" selected="true">ShuffleSplit</option>
        <option value="stratified">StratifiedShuffleSplit -- target values serve as class labels</option>
        <option value="group">GroupShuffleSplit or split by group names</option>
      </param>
      <when value="None">
        <expand macro="train_test_split_test_size"/>
      </when>
      <when value="simple">
        <expand macro="train_test_split_test_size"/>
        <expand macro="random_state"/>
      </when>
      <when value="stratified">
        <expand macro="train_test_split_test_size"/>
        <expand macro="random_state"/>
      </when>
      <when value="group">
        <expand macro="train_test_split_test_size" optional="true"/>
        <expand macro="random_state"/>
        <param argument="group_names" type="text" value="" optional="true" label="Type in group names instead"
        help="For example: chr6, chr7. This parameter is optional. If used, it will override the holdout size and random seed."/>
        <yield/>
      </when>
    </conditional>
    <!--param argument="train_size" type="float" optional="True" value="" label="Train size:"/>-->
  </xml>

  <xml name="train_test_split_test_size" token_optional="false">
    <param name="test_size" type="float" value="0.2" optional="@OPTIONAL@" label="Holdout size" help="Leass than 1, for preportion; greater than 1 (integer), for number of samples."/>
  </xml>

  <xml name="feature_selection_algorithms">
    <option value="SelectKBest" selected="true">SelectKBest - Select features according to the k highest scores</option>
    <option value="GenericUnivariateSelect">GenericUnivariateSelect - Univariate feature selector with configurable strategy</option>
    <option value="SelectPercentile">SelectPercentile - Select features according to a percentile of the highest scores</option>
    <option value="SelectFpr">SelectFpr - Filter: Select the p-values below alpha based on a FPR test</option>
    <option value="SelectFdr">SelectFdr - Filter: Select the p-values for an estimated false discovery rate</option>
    <option value="SelectFwe">SelectFwe - Filter: Select the p-values corresponding to Family-wise error rate</option>
    <option value="VarianceThreshold">VarianceThreshold - Feature selector that removes all low-variance features</option>
    <option value="SelectFromModel">SelectFromModel - Meta-transformer for selecting features based on importance weights</option>
    <option value="RFE">RFE - Feature ranking with recursive feature elimination</option>
    <option value="RFECV">RFECV - Feature ranking with recursive feature elimination and cross-validated selection of the best number of features</option>
    <yield/>
  </xml>

  <xml name="feature_selection_algorithm_details">
    <when value="GenericUnivariateSelect">
      <expand macro="feature_selection_score_function" />
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="mode" type="select" label="Feature selection mode">
          <option value="percentile">percentile</option>
          <option value="k_best">k_best</option>
          <option value="fpr">fpr</option>
          <option value="fdr">fdr</option>
          <option value="fwe">fwe</option>
        </param>
        <param argument="param" type="float" value="" optional="true" label="Parameter of the corresponding mode" help="float or int depending on the feature selection mode" />
      </section>
    </when>
    <when value="SelectPercentile">
      <expand macro="feature_selection_score_function" />
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="percentile" type="integer" value="10" optional="True" label="Percent of features to keep" />
      </section>
    </when>
    <when value="SelectKBest">
      <expand macro="feature_selection_score_function" />
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="k" type="integer" value="10" optional="True" label="Number of top features to select" help="No 'all' option is supported." />
      </section>
    </when>
    <when value="SelectFpr">
      <expand macro="feature_selection_score_function" />
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="alpha" type="float" value="" optional="True" label="Alpha" help="The highest p-value for features to be kept."/>
      </section>
    </when>
    <when value="SelectFdr">
      <expand macro="feature_selection_score_function" />
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="alpha" type="float" value="" optional="True" label="Alpha" help="The highest uncorrected p-value for features to keep."/>
      </section>
    </when>
    <when value="SelectFwe">
      <expand macro="feature_selection_score_function" />
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="alpha" type="float" value="" optional="True" label="Alpha" help="The highest uncorrected p-value for features to keep."/>
      </section>
    </when>
    <when value="VarianceThreshold">
      <section name="options" title="Options" expanded="False">
        <param argument="threshold" type="float" value="0.0" optional="True" label="Threshold" help="Features with a training-set variance lower than this threshold will be removed."/>
      </section>
    </when>
  </xml>

  <xml name="feature_selection_SelectFromModel">
    <when value="SelectFromModel">
      <conditional name="model_inputter">
        <param name="input_mode" type="select" label="Construct a new estimator from a selection list?" >
          <option value="new" selected="true">Yes</option>
          <option value="prefitted">No. Load a prefitted estimator</option>
        </param>
        <when value="new">
          <expand macro="estimator_selector_fs"/>
        </when>
        <when value="prefitted">
          <param name="fitted_estimator" type="data" format='zip' label="Load a prefitted estimator" />
        </when>
      </conditional>
      <expand macro="feature_selection_SelectFromModel_options"/>
    </when>
  </xml>

  <xml name="feature_selection_SelectFromModel_no_prefitted">
    <when value="SelectFromModel">
      <conditional name="model_inputter">
        <param name="input_mode" type="select" label="Construct a new estimator from a selection list?" >
          <option value="new" selected="true">Yes</option>
        </param>
        <when value="new">
          <expand macro="estimator_selector_all"/>
        </when>
      </conditional>
      <expand macro="feature_selection_SelectFromModel_options"/>
    </when>
  </xml>

  <xml name="feature_selection_SelectFromModel_options">
    <section name="options" title="Advanced Options" expanded="False">
      <param argument="threshold" type="text" value="" optional="true" label="threshold" help="The threshold value to use for feature selection. e.g. 'mean', 'median', '1.25*mean'." />
      <param argument="norm_order" type="integer" value="1" label="norm_order" help="Order of the norm used to filter the vectors of coefficients below threshold in the case where the coef_ attribute of the estimator is of dimension 2. " />
      <param argument="max_features" type="integer" value="" optional="true" label="The maximum number of features selected scoring above threshold" help="To disable threshold and only select based on max_features, set threshold=-np.inf."/>
    </section>
  </xml>

  <xml name="feature_selection_RFE">
    <when value="RFE">
      <yield/>
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="n_features_to_select" type="integer" value="" optional="true" label="n_features_to_select" help="The number of features to select. If None, half of the features are selected." />
        <param argument="step" type="float" value="1" label="step" optional="true" help="Default = 1. " />
        <param argument="verbose" type="integer" value="0" label="verbose" help="Controls verbosity of output." />
      </section>
    </when>
  </xml>

  <xml name="feature_selection_RFECV_fs">
    <when value="RFECV">
      <yield/>
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="step" type="float" value="1" label="step" optional="true" help="Default = 1. " />
        <param argument="min_features_to_select" type="integer" value="1" optional="true" label="The minimum number of features to be selected"/>
        <expand macro="cv"/>
        <expand macro="scoring_selection"/>
        <param argument="verbose" type="integer" value="0" label="verbose" help="Controls verbosity of output." />
      </section>
    </when>
  </xml>

  <xml name="feature_selection_RFECV_pipeline">
    <when value="RFECV">
      <yield/>
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="step" type="float" value="1" label="step" optional="true" help="Default = 1. " />
        <param argument="min_features_to_select" type="integer" value="1" optional="true" label="The minimum number of features to be selected"/>
        <expand macro="cv_reduced"/>
        <!-- TODO: group splitter support-->
        <expand macro="scoring_selection"/>
        <param argument="verbose" type="integer" value="0" label="verbose" help="Controls verbosity of output." />
      </section>
    </when>
  </xml>

  <xml name="feature_selection_DyRFECV_fs">
    <when value="DyRFECV">
      <yield/>
      <section name="options" title="Advanced Options" expanded="False">
        <param argument="step" type="text" size="30" value="1" label="step" optional="true" help="Default = 1. Support float, int and list." >
          <sanitizer>
            <valid initial="default">
              <add value="["/>
              <add value="]"/>
            </valid>
          </sanitizer>
        </param>
        <param argument="min_features_to_select" type="integer" value="1" optional="true" label="The minimum number of features to be selected"/>
        <expand macro="cv"/>
        <expand macro="scoring_selection"/>
        <param argument="verbose" type="integer" value="0" label="verbose" help="Controls verbosity of output." />
      </section>
    </when>
  </xml>

  <xml name="feature_selection_pipeline">
    <!--compare to `feature_selection_fs`, no fitted estimator for SelectFromModel and no custom estimator for RFE and RFECV-->
    <conditional name="fs_algorithm_selector">
      <param name="selected_algorithm" type="select" label="Select a feature selection algorithm">
        <expand macro="feature_selection_algorithms"/>
      </param>
      <expand macro="feature_selection_algorithm_details"/>
      <expand macro="feature_selection_SelectFromModel_no_prefitted"/>
      <expand macro="feature_selection_RFE">
        <expand macro="estimator_selector_all"/>
      </expand>  
      <expand macro="feature_selection_RFECV_pipeline">
        <expand macro="estimator_selector_all"/>
      </expand>
      <!-- TODO: add DyRFECV to pipeline-->
    </conditional>
  </xml>

  <xml name="feature_selection_fs">
    <conditional name="fs_algorithm_selector">
      <param name="selected_algorithm" type="select" label="Select a feature selection algorithm">
        <expand macro="feature_selection_algorithms">
          <option value="DyRFECV">DyRFECV - Extended RFECV with changeable steps</option>
        </expand>
      </param>
      <expand macro="feature_selection_algorithm_details"/>
      <expand macro="feature_selection_SelectFromModel"/>
      <expand macro="feature_selection_RFE">
        <expand macro="estimator_selector_fs"/>
      </expand>  
      <expand macro="feature_selection_RFECV_fs">
        <expand macro="estimator_selector_fs"/>
      </expand>
      <expand macro="feature_selection_DyRFECV_fs">
        <expand macro="estimator_selector_fs"/>
      </expand>
    </conditional>
  </xml>

  <xml name="feature_selection_score_function">
    <param argument="score_func" type="select" label="Select a score function">
      <option value="chi2">chi2 - Compute chi-squared stats between each non-negative feature and class</option>
      <option value="f_classif">f_classif - Compute the ANOVA F-value for the provided sample</option>
      <option value="f_regression">f_regression - Univariate linear regression tests</option>
      <option value="mutual_info_classif">mutual_info_classif - Estimate mutual information for a discrete target variable</option>
      <option value="mutual_info_regression">mutual_info_regression - Estimate mutual information for a continuous target variable</option>
    </param>
  </xml>

  <xml name="model_validation_common_options">
    <expand macro="cv"/>
    <expand macro="verbose"/>
    <yield/>
  </xml>

  <xml name="scoring_selection">
    <conditional name="scoring">
      <param name="primary_scoring" type="select" multiple="false" label="Select the primary metric (scoring):" help="Metric to refit the best estimator.">
        <option value="default" selected="true">default with estimator</option>
        <option value="accuracy">Classification -- 'accuracy'</option>
        <option value="balanced_accuracy">Classification -- 'balanced_accuracy'</option>
        <option value="average_precision">Classification -- 'average_precision'</option>
        <option value="f1">Classification -- 'f1'</option>
        <option value="f1_micro">Classification -- 'f1_micro'</option>
        <option value="f1_macro">Classification -- 'f1_macro'</option>
        <option value="f1_weighted">Classification -- 'f1_weighted'</option>
        <option value="f1_samples">Classification -- 'f1_samples'</option>
        <option value="neg_log_loss">Classification -- 'neg_log_loss'</option>
        <option value="precision">Classification -- 'precision'</option>
        <option value="precision_micro">Classification -- 'precision_micro'</option>
        <option value="precision_macro">Classification -- 'precision_macro'</option>
        <option value="precision_wighted">Classification -- 'precision_wighted'</option>
        <option value="precision_samples">Classification -- 'precision_samples'</option>
        <option value="recall">Classification -- 'recall'</option>
        <option value="recall_micro">Classification -- 'recall_micro'</option>
        <option value="recall_macro">Classification -- 'recall_macro'</option>
        <option value="recall_wighted">Classification -- 'recall_wighted'</option>
        <option value="recall_samples">Classification -- 'recall_samples'</option>
        <option value="roc_auc">Classification -- 'roc_auc'</option>
        <option value="explained_variance">Regression -- 'explained_variance'</option>
        <option value="neg_mean_absolute_error">Regression -- 'neg_mean_absolute_error'</option>
        <option value="neg_mean_squared_error">Regression -- 'neg_mean_squared_error'</option>
        <option value="neg_mean_squared_log_error">Regression -- 'neg_mean_squared_log_error'</option>
        <option value="neg_median_absolute_error">Regression -- 'neg_median_absolute_error'</option>
        <option value="r2">Regression -- 'r2'</option>
        <option value="max_error">Regression -- 'max_error'</option>
        <option value="binarize_auc_scorer">anomaly detection -- binarize_auc_scorer</option>
        <option value="binarize_average_precision_scorer">anomaly detection -- binarize_average_precision_scorer</option>
      </param>
      <when value="default"/>
      <when value="accuracy"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="balanced_accuracy"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="average_precision"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="f1"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="f1_micro"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="f1_macro"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="f1_weighted"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="f1_samples"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="neg_log_loss"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="precision"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="precision_micro"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="precision_macro"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="precision_wighted"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="precision_samples"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="recall"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="recall_micro"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="recall_macro"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="recall_wighted"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="recall_samples"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="roc_auc"><expand macro="secondary_scoring_selection_classification"/></when>
      <when value="explained_variance"><expand macro="secondary_scoring_selection_regression"/></when>
      <when value="neg_mean_absolute_error"><expand macro="secondary_scoring_selection_regression"/></when>
      <when value="neg_mean_squared_error"><expand macro="secondary_scoring_selection_regression"/></when>
      <when value="neg_mean_squared_log_error"><expand macro="secondary_scoring_selection_regression"/></when>
      <when value="neg_median_absolute_error"><expand macro="secondary_scoring_selection_regression"/></when>
      <when value="r2"><expand macro="secondary_scoring_selection_regression"/></when>
      <when value="max_error"><expand macro="secondary_scoring_selection_regression"/></when>
      <when value="binarize_auc_scorer"><expand macro="secondary_scoring_selection_anormaly"/></when>
      <when value="binarize_average_precision_scorer"><expand macro="secondary_scoring_selection_anormaly"/></when>
    </conditional>
  </xml>

  <xml name="secondary_scoring_selection_classification">
    <param name="secondary_scoring" type="select" multiple="true" label="Additional scoring used in multi-metric mode:" help="If the same metric with the primary is chosen, the metric will be ignored.">
      <option value="accuracy">Classification -- 'accuracy'</option>
      <option value="balanced_accuracy">Classification -- 'balanced_accuracy'</option>
      <option value="average_precision">Classification -- 'average_precision'</option>
      <option value="f1">Classification -- 'f1'</option>
      <option value="f1_micro">Classification -- 'f1_micro'</option>
      <option value="f1_macro">Classification -- 'f1_macro'</option>
      <option value="f1_weighted">Classification -- 'f1_weighted'</option>
      <option value="f1_samples">Classification -- 'f1_samples'</option>
      <option value="neg_log_loss">Classification -- 'neg_log_loss'</option>
      <option value="precision">Classification -- 'precision'</option>
      <option value="precision_micro">Classification -- 'precision_micro'</option>
      <option value="precision_macro">Classification -- 'precision_macro'</option>
      <option value="precision_wighted">Classification -- 'precision_wighted'</option>
      <option value="precision_samples">Classification -- 'precision_samples'</option>
      <option value="recall">Classification -- 'recall'</option>
      <option value="recall_micro">Classification -- 'recall_micro'</option>
      <option value="recall_macro">Classification -- 'recall_macro'</option>
      <option value="recall_wighted">Classification -- 'recall_wighted'</option>
      <option value="recall_samples">Classification -- 'recall_samples'</option>
      <option value="roc_auc">Classification -- 'roc_auc'</option>
    </param>
  </xml>

  <xml name="secondary_scoring_selection_regression">
    <param name="secondary_scoring" type="select" multiple="true" label="Additional scoring used in multi-metric mode:" help="If the same metric with the primary is chosen, the metric will be ignored.">
      <option value="explained_variance">Regression -- 'explained_variance'</option>
      <option value="neg_mean_absolute_error">Regression -- 'neg_mean_absolute_error'</option>
      <option value="neg_mean_squared_error">Regression -- 'neg_mean_squared_error'</option>
      <option value="neg_mean_squared_log_error">Regression -- 'neg_mean_squared_log_error'</option>
      <option value="neg_median_absolute_error">Regression -- 'neg_median_absolute_error'</option>
      <option value="r2">Regression -- 'r2'</option>
      <option value="max_error">Regression -- 'max_error'</option>
    </param>
  </xml>

  <xml name="secondary_scoring_selection_anormaly">
    <param name="secondary_scoring" type="select" multiple="true" label="Additional scoring used in multi-metric mode:" help="If the same metric with the primary is chosen, the metric will be ignored.">
      <option value="binarize_auc_scorer">anomaly detection -- binarize_auc_scorer</option>
      <option value="binarize_average_precision_scorer">anomaly detection -- binarize_average_precision_scorer</option>
    </param>
  </xml>

  <xml name="pre_dispatch" token_type="hidden" token_default_value="all" token_help="Number of predispatched jobs for parallel execution">
    <param argument="pre_dispatch" type="@TYPE@" value="@DEFAULT_VALUE@" optional="true" label="pre_dispatch" help="@HELP@"/>
  </xml>

  <xml name="estimator_and_hyperparameter">
    <param name="infile_estimator" type="data" format="zip" label="Choose the dataset containing pipeline/estimator object"/>
    <section name="hyperparams_swapping" title="Hyperparameter Swapping" expanded="false">
      <param name="infile_params" type="data" format="tabular" optional="true" label="Choose the dataset containing hyperparameters for the pipeline/estimator above" help="This dataset could be the output of `get_params` in the `Estimator Attributes` tool."/>
      <repeat name="param_set" min="1" max="30" title="New hyperparameter setting">
          <param name="sp_name" type="select" optional="true" label="Choose a parameter name (with current value)">
            <options from_dataset="infile_params" startswith="@">
              <column name="name" index="2"/>
              <column name="value" index="1"/>
              <filter type="unique_value" name="unique_param" column="1"/>
            </options>
          </param>
          <param name="sp_value" type="text" value="" optional="true" label="New value" help="Supports int, float, boolean, single quoted string, and selected object constructor. Similar to the `Parameter settings for search` section in `searchcv` tool except that only single value is expected here.">
            <sanitizer>
              <valid initial="default">
                <add value="&apos;"/>
                <add value="&quot;"/>
              </valid>
            </sanitizer>
          </param>
      </repeat>
    </section>
  </xml>

  <xml name="search_cv_options">
      <expand macro="scoring_selection"/>
      <expand macro="model_validation_common_options"/>
      <!--expand macro="pre_dispatch" default_value="2*n_jobs" help="Controls the number of jobs that get dispatched during parallel execution"/-->
      <param argument="iid" type="boolean" truevalue="booltrue" falsevalue="boolfalse" checked="true" label="iid" help="If True, data is identically distributed across the folds"/>
      <!--param argument="refit" type="boolean" truevalue="booltrue" falsevalue="boolfalse" checked="true" label="refit" help="Refit an estimator using the best found parameters on the whole dataset. Be aware that `refit=True` invokes extra computation, but it's REQUIRED for outputting the best estimator!"/> -->
      <param argument="error_score" type="boolean" truevalue="booltrue" falsevalue="boolfalse" checked="true" label="Raise fit error:" help="If false, the metric score is assigned to NaN if an error occurs in estimator fitting and FitFailedWarning is raised."/>
      <param argument="return_train_score" type="boolean" truevalue="booltrue" falsevalue="boolfalse" checked="false" label="return_train_score" help=""/>
  </xml>

  <xml name="estimator_module_options">
      <option value="svm" selected="true">sklearn.svm</option>
      <option value="linear_model">sklearn.linear_model</option>
      <option value="ensemble">sklearn.ensemble</option>
      <option value="naive_bayes">sklearn.naive_bayes</option>
      <option value="tree">sklearn.tree</option>
      <option value="neighbors">sklearn.neighbors</option>
      <option value="xgboost">xgboost</option>
      <yield/>
  </xml>

  <xml name="estimator_suboptions">
      <when value="svm">
        <param name="selected_estimator" type="select" label="Choose estimator class:">
          <option value="LinearSVC" selected="true">LinearSVC</option>
          <option value="LinearSVR">LinearSVR</option>
          <option value="NuSVC">NuSVC</option>
          <option value="NuSVR">NuSVR</option>
          <option value="OneClassSVM">OneClassSVM</option>
          <option value="SVC">SVC</option>
          <option value="SVR">SVR</option>
        </param>
        <expand macro="estimator_params_text"/>
      </when>
      <when value="linear_model">
        <param name="selected_estimator" type="select" label="Choose estimator class:">
          <option value="ARDRegression" selected="true">ARDRegression</option>
          <option value="BayesianRidge">BayesianRidge</option>
          <option value="ElasticNet">ElasticNet</option>
          <option value="ElasticNetCV">ElasticNetCV</option>
          <option value="HuberRegressor">HuberRegressor</option>
          <option value="Lars">Lars</option>
          <option value="LarsCV">LarsCV</option>
          <option value="Lasso">Lasso</option>
          <option value="LassoCV">LassoCV</option>
          <option value="LassoLars">LassoLars</option>
          <option value="LassoLarsCV">LassoLarsCV</option>
          <option value="LassoLarsIC">LassoLarsIC</option>
          <option value="LinearRegression">LinearRegression</option>
          <option value="LogisticRegression">LogisticRegression</option>
          <option value="LogisticRegressionCV">LogisticRegressionCV</option>
          <option value="MultiTaskLasso">MultiTaskLasso</option>
          <option value="MultiTaskElasticNet">MultiTaskElasticNet</option>
          <option value="MultiTaskLassoCV">MultiTaskLassoCV</option>
          <option value="MultiTaskElasticNetCV">MultiTaskElasticNetCV</option>
          <option value="OrthogonalMatchingPursuit">OrthogonalMatchingPursuit</option>
          <option value="OrthogonalMatchingPursuitCV">OrthogonalMatchingPursuitCV</option>
          <option value="PassiveAggressiveClassifier">PassiveAggressiveClassifier</option>
          <option value="PassiveAggressiveRegressor">PassiveAggressiveRegressor</option>
          <option value="Perceptron">Perceptron</option>
          <option value="RANSACRegressor">RANSACRegressor</option>
          <option value="Ridge">Ridge</option>
          <option value="RidgeClassifier">RidgeClassifier</option>
          <option value="RidgeClassifierCV">RidgeClassifierCV</option>
          <option value="RidgeCV">RidgeCV</option>
          <option value="SGDClassifier">SGDClassifier</option>
          <option value="SGDRegressor">SGDRegressor</option>
          <option value="TheilSenRegressor">TheilSenRegressor</option>
        </param>
        <expand macro="estimator_params_text"/>
      </when>
      <when value="ensemble">
        <param name="selected_estimator" type="select" label="Choose estimator class:">
          <option value="AdaBoostClassifier" selected="true">AdaBoostClassifier</option>
          <option value="AdaBoostRegressor">AdaBoostRegressor</option>
          <option value="BaggingClassifier">BaggingClassifier</option>
          <option value="BaggingRegressor">BaggingRegressor</option>
          <option value="ExtraTreesClassifier">ExtraTreesClassifier</option>
          <option value="ExtraTreesRegressor">ExtraTreesRegressor</option>
          <option value="GradientBoostingClassifier">GradientBoostingClassifier</option>
          <option value="GradientBoostingRegressor">GradientBoostingRegressor</option>
          <option value="IsolationForest">IsolationForest</option>
          <option value="HistGradientBoostingClassifier">HistGradientBoostingClassifier</option>
          <option value="HistGradientBoostingRegressor">HistGradientBoostingRegressor</option>
          <option value="RandomForestClassifier">RandomForestClassifier</option>
          <option value="RandomForestRegressor">RandomForestRegressor</option>
          <option value="RandomTreesEmbedding">RandomTreesEmbedding</option>
          <!--option value="VotingClassifier">VotingClassifier</option-->
        </param>
        <expand macro="estimator_params_text"/>
      </when>
      <when value="naive_bayes">
        <param name="selected_estimator" type="select" label="Choose estimator class:">
          <option value="BernoulliNB" selected="true">BernoulliNB</option>
          <option value="GaussianNB">GaussianNB</option>
          <option value="MultinomialNB">MultinomialNB</option>
        </param>
        <expand macro="estimator_params_text"/>
      </when>
      <when value="tree">
        <param name="selected_estimator" type="select" label="Choose estimator class:">
          <option value="DecisionTreeClassifier" selected="true">DecisionTreeClassifier</option>
          <option value="DecisionTreeRegressor">DecisionTreeRegressor</option>
          <option value="ExtraTreeClassifier">ExtraTreeClassifier</option>
          <option value="ExtraTreeRegressor">ExtraTreeRegressor</option>
        </param>
        <expand macro="estimator_params_text"/>
      </when>
      <when value="neighbors">
        <param name="selected_estimator" type="select" label="Choose estimator class:">
          <option value="KNeighborsClassifier" selected="true">KNeighborsClassifier</option>
          <option value="KNeighborsRegressor">KNeighborsRegressor</option>
          <!--option value="BallTree">BallTree</option-->
          <!--option value="KDTree">KDTree</option-->
          <option value="KernelDensity">KernelDensity</option>
          <option value="LocalOutlierFactor">LocalOutlierFactor</option>
          <option value="RadiusNeighborsClassifier">RadiusNeighborsClassifier</option>
          <option value="RadiusNeighborsRegressor">RadiusNeighborsRegressor</option>
          <option value="NearestCentroid">NearestCentroid</option>
          <option value="NearestNeighbors">NearestNeighbors</option>
        </param>
        <expand macro="estimator_params_text"/>
      </when>
      <when value="xgboost">
        <param name="selected_estimator" type="select" label="Choose estimator class:">
          <option value="XGBRegressor" selected="true">XGBRegressor</option>
          <option value="XGBClassifier">XGBClassifier</option>
        </param>
        <expand macro="estimator_params_text"/>
      </when>
      <yield/>
  </xml>

  <xml name="estimator_selector_all">
    <conditional name="estimator_selector">
      <param name="selected_module" type="select" label="Choose the module that contains target estimator:" >
        <expand macro="estimator_module_options"/>
      </param>
      <expand macro="estimator_suboptions"/>
    </conditional>
  </xml>

  <xml name="estimator_selector_fs">
    <conditional name="estimator_selector">
      <param name="selected_module" type="select" label="Choose the module that contains target estimator:" >
        <expand macro="estimator_module_options">
            <option value="custom_estimator">Load a custom estimator</option>
        </expand>
      </param>
      <expand macro="estimator_suboptions">
        <when value="custom_estimator">
            <param name="c_estimator" type="data" format="zip" label="Choose the dataset containing the custom estimator or pipeline:"/>
        </when>
      </expand>
    </conditional>
  </xml>

  <xml name="estimator_params_text" token_label="Type in parameter settings if different from default:" token_default_value=''
        token_help="Dictionary-capable, e.g., C=1, kernel='linear'. No double quotes. Leave this box blank for default estimator.">
    <param name="text_params" type="text" value="@DEFAULT_VALUE@" optional="true" label="@LABEL@" help="@HELP@">
      <sanitizer>
        <valid initial="default">
          <add value="&apos;"/>
        </valid>
      </sanitizer>
    </param>
  </xml>

  <xml name="kernel_approximation_all">
    <conditional name="kernel_approximation_selector">
      <param name="select_algorithm" type="select" label="Choose a kernel approximation algorithm:">
        <option value="Nystroem" selected="true">Nystroem</option>
        <option value="RBFSampler">RBFSampler</option>
        <option value="AdditiveChi2Sampler">AdditiveChi2Sampler</option>
        <option value="SkewedChi2Sampler">SkewedChi2Sampler</option>
      </param>
      <when value="Nystroem">
        <expand macro="estimator_params_text"
              help="Default(=blank): coef0=None, degree=None, gamma=None, kernel='rbf', kernel_params=None, n_components=100, random_state=None. No double quotes"/>
      </when>
      <when value="RBFSampler">
        <expand macro="estimator_params_text"
              help="Default(=blank): gamma=1.0, n_components=100, random_state=None."/>
      </when>
      <when value="AdditiveChi2Sampler">
        <expand macro="estimator_params_text"
              help="Default(=blank): sample_interval=None, sample_steps=2."/>
      </when>
      <when value="SkewedChi2Sampler">
        <expand macro="estimator_params_text"
              help="Default(=blank): n_components=100, random_state=None, skewedness=1.0."/>
      </when>
    </conditional>
  </xml>

  <xml name="matrix_decomposition_all">
    <conditional name="matrix_decomposition_selector">
      <param name="select_algorithm" type="select" label="Choose a matrix decomposition algorithm:">
        <option value="DictionaryLearning" selected="true">DictionaryLearning</option>
        <option value="FactorAnalysis">FactorAnalysis</option>
        <option value="FastICA">FastICA</option>
        <option value="IncrementalPCA">IncrementalPCA</option>
        <option value="KernelPCA">KernelPCA</option>
        <option value="LatentDirichletAllocation">LatentDirichletAllocation</option>
        <option value="MiniBatchDictionaryLearning">MiniBatchDictionaryLearning</option>
        <option value="MiniBatchSparsePCA">MiniBatchSparsePCA</option>
        <option value="NMF">NMF</option>
        <option value="PCA">PCA</option>
        <option value="SparsePCA">SparsePCA</option>
        <!--option value="SparseCoder">SparseCoder</option-->
        <option value="TruncatedSVD">TruncatedSVD</option>
      </param>
      <when value="DictionaryLearning">
        <expand macro="estimator_params_text"
              help="Default(=blank): alpha=1, code_init=None, dict_init=None, fit_algorithm='lars', max_iter=1000, n_components=None, random_state=None, split_sign=False, tol=1e-08, transform_algorithm='omp', transform_alpha=None, transform_n_nonzero_coefs=None, verbose=False."/>
      </when>
      <when value="FactorAnalysis">
        <expand macro="estimator_params_text"
              help="Default(=blank): copy=True, iterated_power=3, max_iter=1000, n_components=None, noise_variance_init=None, random_state=0, svd_method='randomized', tol=0.01."/>
      </when>
      <when value="FastICA">
        <expand macro="estimator_params_text"
              help="Default(=blank): algorithm='parallel', fun='logcosh', fun_args=None, max_iter=200, n_components=None, random_state=None, tol=0.0001, w_init=None, whiten=True. No double quotes."/>
      </when>
      <when value="IncrementalPCA">
        <expand macro="estimator_params_text"
              help="Default(=blank): batch_size=None, copy=True, n_components=None, whiten=False."/>
      </when>
      <when value="KernelPCA">
        <expand macro="estimator_params_text"
              help="Default(=blank): alpha=1.0, coef0=1, copy_X=True, degree=3, eigen_solver='auto', fit_inverse_transform=False, gamma=None, kernel='linear', kernel_params=None, max_iter=None, n_components=None, random_state=None, remove_zero_eig=False, tol=0. No double quotes."/>
      </when>
      <when value="LatentDirichletAllocation">
        <expand macro="estimator_params_text"
              help="Default(=blank): batch_size=128, doc_topic_prior=None, evaluate_every=-1, learning_decay=0.7, learning_method=None, learning_offset=10.0, max_doc_update_iter=100, max_iter=10, mean_change_tol=0.001, n_components=10, n_topics=None, perp_tol=0.1, random_state=None, topic_word_prior=None, total_samples=1000000.0, verbose=0."/>
      </when>
      <when value="MiniBatchDictionaryLearning">
        <expand macro="estimator_params_text"
              help="Default(=blank): alpha=1, batch_size=3, dict_init=None, fit_algorithm='lars', n_components=None, n_iter=1000, random_state=None, shuffle=True, split_sign=False, transform_algorithm='omp', transform_alpha=None, transform_n_nonzero_coefs=None, verbose=False."/>
      </when>
      <when value="MiniBatchSparsePCA">
        <expand macro="estimator_params_text"
              help="Default(=blank): alpha=1, batch_size=3, callback=None, method='lars', n_components=None, n_iter=100, random_state=None, ridge_alpha=0.01, shuffle=True, verbose=False."/>
      </when>
      <when value="NMF">
        <expand macro="estimator_params_text"
              help="Default(=blank): alpha=0.0, beta_loss='frobenius', init=None, l1_ratio=0.0, max_iter=200, n_components=None, random_state=None, shuffle=False, solver='cd', tol=0.0001, verbose=0."/>
      </when>
      <when value="PCA">
        <expand macro="estimator_params_text"
              help="Default(=blank): copy=True, iterated_power='auto', n_components=None, random_state=None, svd_solver='auto', tol=0.0, whiten=False."/>
      </when>
      <when value="SparsePCA">
        <expand macro="estimator_params_text"
              help="Default(=blank): U_init=None, V_init=None, alpha=1, max_iter=1000, method='lars', n_components=None, random_state=None, ridge_alpha=0.01, tol=1e-08, verbose=False."/>
      </when>
      <when value="TruncatedSVD">
        <expand macro="estimator_params_text"
              help="Default(=blank): algorithm='randomized', n_components=2, n_iter=5, random_state=None, tol=0.0."/>
      </when>
    </conditional>
  </xml>

  <xml name="FeatureAgglomeration">
    <conditional name="FeatureAgglomeration_selector">
      <param name="select_algorithm" type="select" label="Choose the algorithm:">
        <option value="FeatureAgglomeration" selected="true">FeatureAgglomeration</option>
      </param>
      <when value="FeatureAgglomeration">
        <expand macro="estimator_params_text"
              help="Default(=blank): affinity='euclidean', compute_full_tree='auto', connectivity=None, linkage='ward', memory=None, n_clusters=2, pooling_func=np.mean."/>
      </when>
    </conditional>
  </xml>

  <xml name="skrebate">
    <conditional name="skrebate_selector">
      <param name="select_algorithm" type="select" label="Choose the algorithm:">
        <option value="ReliefF">ReliefF</option>
        <option value="SURF">SURF</option>
        <option value="SURFstar">SURFstar</option>
        <option value="MultiSURF">MultiSURF</option>
        <option value="MultiSURFstar">MultiSURFstar</option>
        <!--option value="TuRF">TuRF</option> -->
      </param>
      <when value="ReliefF">
        <expand macro="estimator_params_text"
              help="Default(=blank): discrete_threshold=10, n_features_to_select=10, n_neighbors=100, verbose=False."/>
      </when>
      <when value="SURF">
        <expand macro="estimator_params_text"
              help="Default(=blank): discrete_threshold=10, n_features_to_select=10, verbose=False."/>
      </when>
      <when value="SURFstar">
        <expand macro="estimator_params_text"
              help="Default(=blank): discrete_threshold=10, n_features_to_select=10, verbose=False."/>
      </when>
      <when value="MultiSURF">
        <expand macro="estimator_params_text"
              help="Default(=blank): discrete_threshold=10, n_features_to_select=10, verbose=False."/>
      </when>
      <when value="MultiSURFstar">
        <expand macro="estimator_params_text"
              help="Default(=blank): discrete_threshold=10, n_features_to_select=10, verbose=False."/>
      </when>
      <!--when value="TuRF">
        <expand macro="estimator_params_text"
              help="Default(=blank): core_algorithm='ReliefF', discrete_threshold=10, n_features_to_select=10, n_neighbors=100, pct=0.5, verbose=False."/>
      </when> -->
    </conditional>
  </xml>

  <xml name="imbalanced_learn_sampling">
    <conditional name="imblearn_selector">
      <param name="select_algorithm" type="select" label="Choose the algorithm:">
        <option value="under_sampling.ClusterCentroids" selected="true">under_sampling.ClusterCentroids</option>
        <option value="under_sampling.CondensedNearestNeighbour">under_sampling.CondensedNearestNeighbour</option>
        <option value="under_sampling.EditedNearestNeighbours">under_sampling.EditedNearestNeighbours</option>
        <option value="under_sampling.RepeatedEditedNearestNeighbours">under_sampling.RepeatedEditedNearestNeighbours</option>
        <option value="under_sampling.AllKNN">under_sampling.AllKNN</option>
        <option value="under_sampling.InstanceHardnessThreshold">under_sampling.InstanceHardnessThreshold</option>
        <option value="under_sampling.NearMiss">under_sampling.NearMiss</option>
        <option value="under_sampling.NeighbourhoodCleaningRule">under_sampling.NeighbourhoodCleaningRule</option>
        <option value="under_sampling.OneSidedSelection">under_sampling.OneSidedSelection</option>
        <option value="under_sampling.RandomUnderSampler">under_sampling.RandomUnderSampler</option>
        <option value="under_sampling.TomekLinks">under_sampling.TomekLinks</option>
        <option value="over_sampling.ADASYN">over_sampling.ADASYN</option>
        <option value="over_sampling.RandomOverSampler">over_sampling.RandomOverSampler</option>
        <option value="over_sampling.SMOTE">over_sampling.SMOTE</option>
        <option value="over_sampling.SVMSMOTE">over_sampling.SVMSMOTE</option>
        <option value="over_sampling.BorderlineSMOTE">over_sampling.BorderlineSMOTE</option>
        <option value="over_sampling.SMOTENC">over_sampling.SMOTENC</option>
        <option value="combine.SMOTEENN">combine.SMOTEENN</option>
        <option value="combine.SMOTETomek">combine.SMOTETomek</option>
        <option value="Z_RandomOverSampler">Z_RandomOverSampler - for regression</option>
      </param>
      <when value="under_sampling.ClusterCentroids">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, estimator=None, voting='auto'."/>
      </when>
      <when value="under_sampling.CondensedNearestNeighbour">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, n_neighbors=None, n_seeds_S=1."/>
      </when>
      <when value="under_sampling.EditedNearestNeighbours">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, n_neighbors=3, max_iter=100, kind_sel='all'."/>
      </when>
      <when value="under_sampling.RepeatedEditedNearestNeighbours">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, n_neighbors=3, max_iter=100, kind_sel='all'."/>
      </when>
      <when value="under_sampling.AllKNN">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, n_neighbors=3, kind_sel='all', allow_minority=False."/>
      </when>
      <when value="under_sampling.InstanceHardnessThreshold">
        <expand macro="estimator_params_text"
              help="Default(=blank): estimator=None, sampling_strategy='auto', random_state=None, cv=5."/>
      </when>
      <when value="under_sampling.NearMiss">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, version=1, n_neighbors=3, n_neighbors_ver3=3."/>
      </when>
      <when value="under_sampling.NeighbourhoodCleaningRule">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, n_neighbors=3, kind_sel='all', threshold_cleaning=0.5."/>
      </when>
      <when value="under_sampling.OneSidedSelection">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, n_neighbors=None, n_seeds_S=1."/>
      </when>
      <when value="under_sampling.RandomUnderSampler">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, replacement=False."/>
      </when>
      <when value="under_sampling.TomekLinks">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None."/>
      </when>
      <when value="over_sampling.ADASYN">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, n_neighbors=5."/>
      </when>
      <when value="over_sampling.RandomOverSampler">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None."/>
      </when>
      <when value="over_sampling.SMOTE">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, k_neighbors=5."/>
      </when>
      <when value="over_sampling.SVMSMOTE">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', k_neighbors=5, m_neighbors=10, out_step=0.5, random_state=None, svm_estimator=None."/>
      </when>
      <when value="over_sampling.BorderlineSMOTE">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', k_neighbors=5, kind='borderline-1', m_neighbors=10, random_state=None."/>
      </when>
      <when value="over_sampling.SMOTENC">
        <expand macro="estimator_params_text"
              help="Default: categorical_features=[], sampling_strategy='auto', random_state=None, k_neighbors=5."/>
      </when>
      <when value="combine.SMOTEENN">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, smote=None, enn=None."/>
      </when>
      <when value="combine.SMOTETomek">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, smote=None, tomek=None."/>
      </when>
      <when value="Z_RandomOverSampler">
        <expand macro="estimator_params_text"
              help="Default(=blank): sampling_strategy='auto', random_state=None, negative_thres=0, positive_thres=-1."/>
      </when>
    </conditional>
  </xml>

  <xml name="stacking_ensemble_inputs">
    <section name="options" title="Advanced Options" expanded="false">
        <yield/>
        <param argument="use_features_in_secondary" type="boolean" truevalue="booltrue" falsevalue="boolfalse" checked="false"/>
        <param argument="store_train_meta_features" type="boolean" truevalue="booltrue" falsevalue="boolfalse" checked="false"/>
    </section>
  </xml>

  <xml name="stacking_base_estimator">
    <conditional name="estimator_selector">
        <param name="selected_module" type="select" label="Choose the module that contains target estimator:" >
            <expand macro="estimator_module_options">
                <option value="custom_estimator">Load a custom estimator</option>
            </expand>
        </param>
        <expand macro="estimator_suboptions">
            <when value="custom_estimator">
                <param name="c_estimator" type="data" format="zip" label="Choose the dataset containing the custom estimator or pipeline"/>
            </when>
        </expand>
    </conditional>
  </xml>

  <xml name="stacking_voting_weights">
    <section name="options" title="Advanced Options" expanded="false">
        <param argument="weights" type="text" value="[]" optional="true" help="Sequence of weights (float or int). Uses uniform weights if None (`[]`).">
          <sanitizer>
            <valid initial="default">
              <add value="["/>
              <add value="]"/>
            </valid>
          </sanitizer>
        </param>
        <yield/>
    </section>
  </xml>

  <xml name="preprocessors_sequence_encoders">
    <conditional name="encoder_selection">
        <param name="encoder_type" type="select" label="Choose the sequence encoder class">
            <option value="GenomeOneHotEncoder">GenomeOneHotEncoder</option>
            <option value="ProteinOneHotEncoder">ProteinOneHotEncoder</option>
        </param>
        <when value="GenomeOneHotEncoder">
            <expand macro="preprocessors_sequence_encoder_arguments"/>
        </when>
        <when value="ProteinOneHotEncoder">
            <expand macro="preprocessors_sequence_encoder_arguments"/>
        </when>
    </conditional>
  </xml>

  <xml name="preprocessors_sequence_encoder_arguments">
    <param argument="seq_length" type="integer" value="" min="0" optional="true" help="Integer. Sequence length"/>
    <param argument="padding" type="boolean" truevalue="booltrue" falsevalue="boolfalse" checked="true" help="Whether to pad or truncate sequence to meet the sequence length."/>
  </xml>

  <!-- Outputs -->

  <xml name="output">
    <outputs>
      <data format="tabular" name="outfile_predict">
          <filter>selected_tasks['selected_task'] == 'load'</filter>
      </data>
      <data format="zip" name="outfile_fit" label="${tool.name}.${selected_tasks.selected_algorithms.selected_algorithm}">
          <filter>selected_tasks['selected_task'] == 'train'</filter>
      </data>
    </outputs>
  </xml>

  <!--Citations-->
  <xml name="eden_citation">
    <citations>
        <citation type="doi">10.5281/zenodo.15094</citation>
    </citations>
  </xml>

  <xml name="sklearn_citation">
    <citations>
        <citation type="bibtex">
          @article{scikit-learn,
            title={Scikit-learn: Machine Learning in {P}ython},
            author={Pedregosa, F. and Varoquaux, G. and Gramfort, A. and Michel, V.
                    and Thirion, B. and Grisel, O. and Blondel, M. and Prettenhofer, P.
                    and Weiss, R. and Dubourg, V. and Vanderplas, J. and Passos, A. and
                    Cournapeau, D. and Brucher, M. and Perrot, M. and Duchesnay, E.},
            journal={Journal of Machine Learning Research},
            volume={12},
            pages={2825--2830},
            year={2011}
          }
        </citation>
        <yield/>
    </citations>
  </xml>

  <xml name="scipy_citation">
    <citations>
        <citation type="bibtex">
          @Misc{,
          author =    {Eric Jones and Travis Oliphant and Pearu Peterson and others},
          title =     {{SciPy}: Open source scientific tools for {Python}},
          year =      {2001--},
          url = "http://www.scipy.org/",
          note = {[Online; accessed 2016-04-09]}
        }
        </citation>
    </citations>
  </xml>

  <xml name="skrebate_citation">
    <citation type="bibtex">
      @article{DBLP:journals/corr/abs-1711-08477,
        author    = {Ryan J. Urbanowicz and
                    Randal S. Olson and
                    Peter Schmitt and
                    Melissa Meeker and
                    Jason H. Moore},
        title     = {Benchmarking Relief-Based Feature Selection Methods},
        journal   = {CoRR},
        volume    = {abs/1711.08477},
        year      = {2017},
        url       = {http://arxiv.org/abs/1711.08477},
        archivePrefix = {arXiv},
        eprint    = {1711.08477},
        timestamp = {Mon, 13 Aug 2018 16:46:04 +0200},
        biburl    = {https://dblp.org/rec/bib/journals/corr/abs-1711-08477},
        bibsource = {dblp computer science bibliography, https://dblp.org}
      }
    </citation>
  </xml>

  <xml name="xgboost_citation">
    <citation type="bibtex">
      @inproceedings{Chen:2016:XST:2939672.2939785,
        author = {Chen, Tianqi and Guestrin, Carlos},
        title = {{XGBoost}: A Scalable Tree Boosting System},
        booktitle = {Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining},
        series = {KDD '16},
        year = {2016},
        isbn = {978-1-4503-4232-2},
        location = {San Francisco, California, USA},
        pages = {785--794},
        numpages = {10},
        url = {http://doi.acm.org/10.1145/2939672.2939785},
        doi = {10.1145/2939672.2939785},
        acmid = {2939785},
        publisher = {ACM},
        address = {New York, NY, USA},
        keywords = {large-scale machine learning},
      }
    </citation>
  </xml>

  <xml name="imblearn_citation">
    <citation type="bibtex">
      @article{JMLR:v18:16-365,
        author  = {Guillaume  Lema{{\^i}}tre and Fernando Nogueira and Christos K. Aridas},
        title   = {Imbalanced-learn: A Python Toolbox to Tackle the Curse of Imbalanced Datasets in Machine Learning},
        journal = {Journal of Machine Learning Research},
        year    = {2017},
        volume  = {18},
        number  = {17},
        pages   = {1-5},
        url     = {http://jmlr.org/papers/v18/16-365.html}
      }
    </citation>
  </xml>

  <xml name="selene_citation">
    <citation type="bibtex">
      @article{chen2019selene,
        title={Selene: a PyTorch-based deep learning library for sequence data},
        author={Chen, Kathleen M and Cofer, Evan M and Zhou, Jian and Troyanskaya, Olga G},
        journal={Nature methods},
        volume={16},
        number={4},
        pages={315},
        year={2019},
        publisher={Nature Publishing Group}
      }
    </citation>
  </xml>

</macros>
