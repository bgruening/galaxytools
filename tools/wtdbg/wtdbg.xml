<tool id="wtdbg" name="wtdbg" version="0.1.0">
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements" />
    <command detect_errors="exit_code"><![CDATA[
        wtdbg
        -t \${GALAXY_SLOTS:-4} 
        -i $input1 
        -fo dbg 
        --tidy-reads 5000 
        --edge-min 2 
        --rescue-low-cov-edges
        &&
        wtdbg-cns 
        -t \${GALAXY_SLOTS:-4} 
        -i dbg.ctg.lay 
        -o dbg.ctg.lay.fa
    ]]></command>
    <inputs>
        <param type="data" name="input1" format="fasta" />
    </inputs>
    <outputs>
        <data name="output1" format="fasta" from_work_dir="dbg.ctg.lay.fa" />
    </outputs>
    <tests>
        <test>
            <param name="input1" value="ecoli-reads.fa"/>
            <output name="output1" file="dbg.ctg.lay.fa"/>
        </test>
    </tests>
    <help><![CDATA[
        WTDBG: De novo assembler for long noisy sequences
  ]]></help>
    <expand macro="citations" />
</tool>

<!--                
        Usage: wtdbg [options]
 
            Options:
            -t <int>    Number of threads, 0: all cores, [0]
            -i <string> Long reads sequences file, + *
            -I <string> Error-free sequences file, +
            -o <string> Prefix of output files, *
            -f          Force overwrite
            -k <int>    Kmer fsize, 0 <= k <= 25, [0]
            -p <int>    Kmer psize, 0 <= p <= 25, [21]
                       k + p <= 25, seed is <k-mer>+<p-homopolymer-compressed>
            -K <float>  Filter high frequency kmers, maybe repetitive, [1000]
                       if K >= 1, take the integer value as cutoff, MUST <= 65535
                       else, mask the top fraction part high frequency kmers
            -E <int>    Min kmer frequency, [2]
            -F          Filter low frequency kmers by a 4G-bytes array (max_occ=3 2-bits). Here, -E must greater than 1
            -S <int>    Subsampling kmers, 1/(<-S>) kmers are indexed, [4]
                       -S is very useful in saving memeory and speeding up
                       please note that subsampling kmers will have less matched length
            -X <int>    Max number of bin(256bp) in one gap, [4]
            -Y <int>    Max number of bin(256bp) in one deviation, [4]
            -x <int>    penalty for BIN gap, [-7]
            -y <int>    penalty for BIN deviation, [-21]
            -l <float>  Min length of alignment, [2048]
            -m <float>  Min matched, [200]
            -s <float>  Max length variation of two aligned fragments, [0.2]
            -q          Quiet
            -v          Verbose, +
            -help      Show more options

    $ wtdbg-cns -h
    WTDBG-CNS: Consensuser for wtdbg
    Author: Jue Ruan <ruanjue@gmail.com>
    Version: 1.1
    Usage: wtdbg-cns [options]
    Options:
     -t <int>    Number of threads, [1]
     -i <string> Input file(s) *.utg.cns from wtdbg, +, [STDIN]
     -o <string> Output files, [STDOUT]
     -f          Force overwrite
     -j <int>    Expected length of node, or say the overlap length of two adject units in layout file, [1000] bp
    BEG DBG options
     -k <int>    Kmer size for long reads, [15]
     -Z <int>    Z-cutoff, drop the lower  (score / <-X>), [4]
     -W <int>    W-cutoff, drop the lagger (position), [48]
                 In DAG correction, -W set the bandwidth of alignment
     -H <int>    High coverage bonus, [1]
     -L <int>    High coverage cutoff = avg_cov / <-L> [10]
     -c <int>    Candidate strategy, 0: best-kmers, 1: median length, 2: first (include), 3: first (exclude), 4: longest, 5, shortest, [0]
                 In DAG correction, force to use strategy 2
    END DBG options
     -M <int>    Match score, [2]
     -X <int>    Mismatch score, [-7]
     -I <int>    Insertion score, [-3]
     -D <int>    Deletion score, [-4]
     -E <int>    Gap extension score, [-2]
     -m <int>    1: DBG correction; 2: DAG correction, [1]
     -S <int>    whether to correct structure before error correction, [1]
     -v          Verbose


 -->