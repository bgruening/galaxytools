<tool id="wtdbg" name="WTDBG" version="1.2.8.1">
    <description>- De novo assembler AND consensuser for long noisy sequences</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements" />
    <version_command>wtdbg -help | grep 'Version:'</version_command>
    <command detect_errors="exit_code"><![CDATA[
        wtdbg
        -t \${GALAXY_SLOTS:-4} 
        -i $i
        -o 'dbg' 
        #if $I:
            -I '$I'
        #end if
        -k $k
        -p $p
        -K $K
        -E $E
        $F
        -S $S
        -X $X
        -Y $Y
        -x $x
        -y $y
        -l $l
        -m $m
        -s $s
        $v
        --tidy-reads $tidy_reads 
        --edge-min $edge_min 
        $rescue_low_cov_edges

        &&
        
        wtdbg-cns 
        -t \${GALAXY_SLOTS:-4} 
        -o dbg.ctg.lay.fa
        -i dbg.ctg.lay
        -j $cns.j
        -k $cns.k
        -Z $cns.Z
        -W $cns.W
        -H $cns.H
        -L $cns.L
        -c $cns.c
        -M $cns.M
        -X $cns.X
        -I $cns.I
        -D $cns.D
        -E $cns.E
        -m $cns.m
        -S $cns.S
        $v
        
        
    ]]></command>
    <inputs>
        <param type="data" argument="-i" format="fasta,fasta.gz" label="Long reads sequences file"/>
        <param type="data" argument="-I" format="fasta,fasta.gz" optional="True" label="Error-free sequences file"/>
        <param argument="k" type="integer" value="0" min="0" max="25" label="Kmer fsize" />
        <param argument="p" type="integer" value="21" min="0" max="25" label="Kmer psize" />
        <param argument="K" type="float" value="1000" min="0" max="65535" label="Filter high frequency kmers" />
        <param argument="E" type="integer" value="2" label="Min kmer frequency" />
        <param argument="F" type="boolean" truevalue="-F" falsevalue="" checked="False" label="Filter low frequency kmers by a 4G-bytes array" />
        <param argument="S" type="integer" value="4" label="Subsampling kmers, 1/S kmers are indexed" />
        <param argument="X" type="integer" value="4" label="Max number of bin(256bp) in one gap" />
        <param argument="Y" type="integer" value="4" label="Max number of bin(256bp) in one deviation" />
        <param argument="x" type="integer" value="-7" label="penalty for BIN gap" />
        <param argument="y" type="integer" value="-21" label="penalty for BIN deviation" />
        <param argument="l" type="float" value="2048" label="Min length of alignment" />
        <param argument="m" type="float" value="200" label="Min matched" />
        <param argument="s" type="float" value="0.2" label="Max length variation of two aligned fragments" />
        <param argument="v" type="boolean" truevalue="-v" falsevalue="" checked="False" label="Verbose" />

        <param argument="--tidy-reads" name="tidy_reads" type="integer" value="0" label="Filter reads less than tidy-reads" />
        <param argument="--edge-min" name="edge_min" type="integer" value="3" label="The minimal depth of a valid edge set to" />
        <param argument="--rescue-low-cov-edges" name="rescue_low_cov_edges" type="boolean" truevalue="--rescue-low-cov-edges" 
          falsevalue="" label="Try to rescue low coverage edges" />

        <section name="cns" title="Consensus options">
            <!-- optional inputs -->
            <!-- <param argument="-i" type="data" format="utg.cns" label="Input file(s) *.utg.cns" /> -->

            <param argument="-j" type="integer" value="1000" label="Expected length of node" />
            <param argument="-k" type="integer" value="15" label="Kmer size for long reads" />
            <param argument="-Z" type="integer" value="4" label="Z-cutoff, drop the lower" />
            <param argument="-W" type="integer" value="48" label="W-cutoff, drop the lagger (position)" />
            <param argument="-H" type="integer" value="1" label="High coverage bonus" />
            <param argument="-L" type="integer" value="10" label="High coverage cutoff" />
            <param argument="-c" type="integer" value="0" label="Candidate strategy, 0: best-kmers, 1: median length, 2: first (include), 3: first (exclude), 4: longest, 5, shortest" />
            <param argument="-M" type="integer" value="2" label="Match score" />
            <param argument="-X" type="integer" value="-7" label="Mismatch score" />
            <param argument="-I" type="integer" value="-3" label="Insertion score" />
            <param argument="-D" type="integer" value="-4" label="Deletion score" />
            <param argument="-E" type="integer" value="-2" label="Gap extension score" />
            <param argument="-m" type="integer" value="1" label="1: DBG correction; 2: DAG correction" />
            <param argument="-S" type="integer" value="1" label="correct structure before error correction" />
            <param argument="-v" type="boolean" truevalue="-v" falsevalue="" checked="False" label="Verbose" />
        </section>

    </inputs>
    <outputs>
        <data name="output_alignments" format="fasta" label="${tool.name}  alignments" from_work_dir="dbg.alignments" />
        <data name="output_ctglay" format="text" label="${tool.name}  contigs layout" from_work_dir="dbg.ctg.lay" />
        <data name="output_consensus" format="fasta" label="${tool.name} consensus" from_work_dir="dbg.ctg.lay.fa" />
    </outputs>
    <tests>
        <test>
            <param name="i" value="ecoli-reads.fa"/>
            <output name="output_alignments" file="result1.alignments"/>
            <output name="output_ctglay" file="result1.ctg.lay"/>
            <output name="output_consensus" file="consensus_result1.fa"/>
        </test>
        <test>
            <param name="i" value="ecoli-reads.fa"/>
            <param name="tidy_reads" value="5000"/>
            <param name="edge_min" value="2"/>
            <param name="rescue_low_cov_edges" value="True"/>

            <output name="output_consensus" file="consensus_result2.fa"/>
        </test>
        <test>
            <param name="i" value="ecoli-reads.fa"/>
            <param name="cns.c" value="1"/>
            <param name="cns.E" value="-3"/>
            <param name="cns.j" value="500"/>
            <param name="cns.m" value="2"/>
            <param name="cns.k" value="5"/>
            <output name="output_consensus" file="consensus_result3.fa"/>
        </test>
    </tests>
    
    <help><![CDATA[
        WTDBG: De novo assembler for long noisy sequences
  ]]></help>
    <expand macro="citations" />
</tool>

<!--                
        Usage: wtdbg [options]
 
            Options:
            -t <int>    Number of threads, 0: all cores, [0]
            -i <string> Long reads sequences file, + *
            -I <string> Error-free sequences file, +
            -o <string> Prefix of output files, *
            -f          Force overwrite
            -k <int>    Kmer fsize, 0 <= k <= 25, [0]
            -p <int>    Kmer psize, 0 <= p <= 25, [21]
                       k + p <= 25, seed is <k-mer>+<p-homopolymer-compressed>
            -K <float>  Filter high frequency kmers, maybe repetitive, [1000]
                       if K >= 1, take the integer value as cutoff, MUST <= 65535
                       else, mask the top fraction part high frequency kmers
            -E <int>    Min kmer frequency, [2]
            -F          Filter low frequency kmers by a 4G-bytes array (max_occ=3 2-bits). Here, -E must greater than 1
            -S <int>    Subsampling kmers, 1/(<-S>) kmers are indexed, [4]
                       -S is very useful in saving memeory and speeding up
                       please note that subsampling kmers will have less matched length
            -X <int>    Max number of bin(256bp) in one gap, [4]
            -Y <int>    Max number of bin(256bp) in one deviation, [4]
            -x <int>    penalty for BIN gap, [-7]
            -y <int>    penalty for BIN deviation, [-21]
            -l <float>  Min length of alignment, [2048]
            -m <float>  Min matched, [200]
            -s <float>  Max length variation of two aligned fragments, [0.2]
            -q          Quiet
            -v          Verbose, +
            -help      Show more options

    $ wtdbg-cns -h
    WTDBG-CNS: Consensuser for wtdbg
    Author: Jue Ruan <ruanjue@gmail.com>
    Version: 1.1
    Usage: wtdbg-cns [options]
    Options:
     -t <int>    Number of threads, [1]
     -i <string> Input file(s) *.utg.cns from wtdbg, +, [STDIN]
     -o <string> Output files, [STDOUT]
     -f          Force overwrite
     -j <int>    Expected length of node, or say the overlap length of two adject units in layout file, [1000] bp
    BEG DBG options
     -k <int>    Kmer size for long reads, [15]
     -Z <int>    Z-cutoff, drop the lower  (score / <-X>), [4]
     -W <int>    W-cutoff, drop the lagger (position), [48]
                 In DAG correction, -W set the bandwidth of alignment
     -H <int>    High coverage bonus, [1]
     -L <int>    High coverage cutoff = avg_cov / <-L> [10]
     -c <int>    Candidate strategy, 0: best-kmers, 1: median length, 2: first (include), 3: first (exclude), 4: longest, 5, shortest, [0]
                 In DAG correction, force to use strategy 2
    END DBG options
     -M <int>    Match score, [2]
     -X <int>    Mismatch score, [-7]
     -I <int>    Insertion score, [-3]
     -D <int>    Deletion score, [-4]
     -E <int>    Gap extension score, [-2]
     -m <int>    1: DBG correction; 2: DAG correction, [1]
     -S <int>    whether to correct structure before error correction, [1]
     -v          Verbose


 -->