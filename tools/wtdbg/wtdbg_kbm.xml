<tool id="wtdbg_kbm" name="wtdbg_kbm" version="1.2.8.1">
   <description>- kbm is a simple instance which implemented kmer-binmap
         it maps query sequence against reference by kmer matching</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements" />
    <command detect_errors="exit_code"><![CDATA[
        kbm 
        -t \${GALAXY_SLOTS:-4}
        -d '$input1' 
        -i '$input2' 
        -o reads.kbmap
    ]]></command>
    <inputs>
        <param type="data" name="input1" format="fasta" />
        <param type="data" name="input2" format="fasta" />
    </inputs>
    <outputs>
        <data name="output1" format="tabular" from_work_dir="reads.kbmap" />
    </outputs>
    <tests>
        <test>
            <param name="input1" value="ecoli-ref.fa"/>
            <param name="input2" value="ecoli-reads.fa"/>
            <output name="output1" file="ecoli-reads_result1.kbmap"/>
        </test>
    </tests>
    <help><![CDATA[
        Program: kbm is a simple instance which implemented kmer-binmap
        it maps query sequence against reference by kmer matching
        matched kmer-pairs are bined (256bp) and counted in a matrix
        dynamic programming is used to search the best path
        Version: 1.2.8 r1 (20171129)
        Author: Jue Ruan <ruanjue@gmail.com>
        Usage: kbm <options> [start|list|stop]
    ]]></help>
    <expand macro="citations" />
</tool>
<!-- 
        Options:
            -i <string> File(s) of query sequences, +, [STDIN]
            -d <string> File(s) of reference sequences, +, [<-i>]
            -o <string> Output file, [STDOUT]
            -I  Interactive mode
                 e.g. `mkfifo pipe` then `while true; do cat pipe && sleep 1; done | kbm -t 8 -I -d ref.fa -i - -Hk 21 -S 4`
                 then `cat 1.fq >pipe; cat 2.fq >pipe`, fastq format is better in interaction
            -f          Force overwrite
            -t <int>    Number of threads, 0: all cores, [1]
            -k <int>    Kmer-f size, <= 23, [0]
            -p <int>    Kmer-p size, <= 23, [21]
            -K <float>  Filter high frequency kmers, maybe repetitive, [1000]
                     if K >= 1, take the integer value as cutoff, MUST <= 65535
                     else, mask the top fraction part high frequency kmers
            -E <int>    Min kmer frequency, [1]
            -F          Filter low frequency kmers by a 4G-bytes array (max_occ=3 2-bits). Here, -E must greater than 1
            -O <int>    Filter low complexity bins (#indexed_kmer less than <-O>), [2]
            -S <int>    Subsampling kmers, 1/(<-S>) kmers are indexed, [4]
                 -S is very useful in saving memeory and speeding up
                 please note that subsampling kmers will have less matched length
            -B <int>    Select no more than n seeds in a query bin, [32]
                     If you are using shared kbmidx by other process using -D too, it will bring wrong behavior
            -D <int>    Strand of alignment, 1: forward, 2: reverse, 3: both, [3]
            -X <int>    Max number of bin(256bp) in one gap, [4]
            -Y <int>    Max number of bin(256bp) in one deviation, [4]
            -Z <float>  Max fraction of gapped BINs / aligned BINs, [0.6]
            -x <int>    penalty for BIN gap, [-7]
            -y <int>    penalty for BIN deviation, [-21]
            -l <int>    Min alignment length, [2048]
            -m <int>    Min matched length, [200]
            -s <float>  Max length variation of two aligned fragments, [0.2]
            -c          Insist to query contained reads against all
            -C          Chainning alignments
            -n <int>    Max hits per query, [1000]
            -T <int>    For debug, [0]
            -W <string> Dump kbm index to file, [NULL]
            -R <string> Load kbm index from file, [NULL]
            -q          Quiet
            Server start: {kbm -R <wt.fa.kbmidx> start}, will mmap wt.fa.kbmidx into mmeory
            Server  list: {kbm -R <wt.fa.kbmidx> list [10]}, will list the object tree in file
            Server  stop: {kbm -R <wt.fa.kbmidx> stop},  will remove the mmap object
 -->