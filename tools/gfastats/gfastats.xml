<tool id="gfastats" name="gfastats" version="@TOOL_VERSION@+galaxy@SUFFIX_VERSION@" profile="20.01">
    <description>the swiss army knife for genome assembly</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements" />
    <expand macro="biotools"/>
    <version_command>gfastats --version</version_command>
    <command detect_errors="exit_code"><![CDATA[
        gfstats
        $input_file
        #if $expected_genomesize
            $expected_genomesize
        #end if
        #if $target_sequence
            #if $coordinates
                $target_sequence:$coordinates
            #else
                $target_sequence
            #end if
        #end if
        -o $output_format
        -s $output_size
        -b $out_coord
        #if $include_bed
            -i $include_bed
        #end if
        #if $exclude_bed
            -e $exclude_bed
        #end if
        $tabular_output
        --stats 
        $seq_report
        #if $seq_report
            $out_sequence
        #end if
        $nstar_report
        #if $swiss_army
            -k $swiss_army
        #end if
        --verbose
        --cmd
        #if $output_format == 'FASTA'
            #if $line_length
                --line-length $line_length
            #end if
        #end if
        --
    ]]></command>
    <inputs>
        <param name="input_file" argument="--fasta" type="data" format="fasta,fastq,fastqsanger,gfa,fasta.gz,fastq.gz,fastqsanger.gz,gfa.gz" label="" help="TODO" />
     </inputs>
    <outputs>
    </outputs>
    <tests>
        <!--Test 01: pacbio-raw-->
        <test expect_num_outputs="5">
            <param name="inputs" ftype="fastq.gz" value="ecoli_01.fastq.gz,ecoli_02.fastq.gz,ecoli_03.fastq.gz,ecoli_04.fastq.gz,ecoli_05.fastq.gz,ecoli_06.fastq.gz,ecoli_07.fastq.gz"/>
            <param name="mode" value="--pacbio-raw"/>
            <param name="iterations" value="0"/>
            <param name="generate_log" value="true"/>
            <output name="assembly_info" file="result1_assembly_info.txt" ftype="tabular" compare="sim_size"/>
            <output name="assembly_graph" file="result1_assembly_graph.dot" ftype="graph_dot" compare="sim_size"/>
            <output name="assembly_gfa" file="result1_assembly_graph.gfa" ftype="txt" compare="sim_size"/>
            <output name="consensus" file="result1_assembly.fasta" ftype="fasta" compare="sim_size"/>
            <output name="flye_log" file="result1.log" ftype="txt" compare="sim_size"/>
        </test>
        <!--Test 02: nano raw-->
        <test expect_num_outputs="4">
            <param name="inputs" ftype="fasta.gz" value="nanopore.fasta.gz"/>
            <param name="mode" value="--nano-raw"/>
            <param name="iterations" value="0"/>
            <output name="assembly_info" ftype="tabular">
                <assert_contents>
                    <has_size value="95" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_graph" ftype="graph_dot">
                <assert_contents>
                    <has_size value="803" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_gfa" ftype="txt">
                <assert_contents>
                    <has_size value="35047" delta="100"/>
               </assert_contents>
            </output>
            <output name="consensus" ftype="fasta">
                <assert_contents>
                    <has_size value="35573" delta="100"/>
               </assert_contents>
            </output>
        </test>
        <!--Test 03: reduce coverage-->
        <test expect_num_outputs="4">
            <param name="inputs" ftype="fastq.gz" value="ecoli_hifi_01.fastq.gz,ecoli_hifi_02.fastq.gz,ecoli_hifi_03.fastq.gz,ecoli_hifi_04.fastq.gz,ecoli_hifi_05.fastq.gz,ecoli_hifi_06.fastq.gz,ecoli_hifi_07.fastq.gz,ecoli_hifi_08.fastq.gz,ecoli_hifi_09.fastq.gz"/>
            <conditional name="mode_conditional">
                <param name="mode" value="--nano-raw"/>
            </conditional>
            <conditional name="asm">
                <param name="asm_select" value="true" />
                <param name="asm" value="30"/>
                <param name="genome_size" value="3980000"/>
            </conditional>
            <output name="assembly_info" ftype="tabular">
                <assert_contents>
                    <has_size value="286" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_graph" ftype="graph_dot">
                <assert_contents>
                    <has_size value="1840" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_gfa" ftype="txt">
                <assert_contents>
                    <has_size value="420752" delta="100"/>
               </assert_contents>
            </output>
            <output name="consensus" ftype="fasta">
                <assert_contents>
                    <has_size value="427580" delta="100"/>
               </assert_contents>
            </output>
        </test>
        <!--Test 04: metagenomic mode-->
        <test expect_num_outputs="4">
            <param name="inputs" ftype="fastq.gz" value="ecoli_01.fastq.gz,ecoli_02.fastq.gz,ecoli_03.fastq.gz,ecoli_04.fastq.gz,ecoli_05.fastq.gz,ecoli_06.fastq.gz,ecoli_07.fastq.gz"/>
            <conditional name="mode_conditional">
                <param name="mode" value="--pacbio-raw"/>
            </conditional>
            <param name="meta" value="true"/>
            <output name="assembly_info" ftype="tabular">
                <assert_contents>
                    <has_size value="95" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_graph" ftype="graph_dot">
                <assert_contents>
                    <has_size value="367" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_gfa" ftype="txt">
                <assert_contents>
                    <has_size value="418729" delta="100"/>
               </assert_contents>
            </output>
            <output name="consensus" ftype="fasta">
                <assert_contents>
                    <has_size value="425667" delta="100"/>
               </assert_contents>
            </output>
        </test>
        <!--Test 05: nanopore HQ mode-->
        <test expect_num_outputs="4">
            <param name="inputs" ftype="fastq.gz" value="ecoli_hifi_01.fastq.gz,ecoli_hifi_02.fastq.gz,ecoli_hifi_03.fastq.gz,ecoli_hifi_04.fastq.gz,ecoli_hifi_05.fastq.gz,ecoli_hifi_06.fastq.gz,ecoli_hifi_07.fastq.gz,ecoli_hifi_08.fastq.gz,ecoli_hifi_09.fastq.gz"/>
            <conditional name="mode_conditional">
                <param name="mode" value="--nano-hq"/>
            </conditional>
            <param name="min_overlap" value="1000"/>
            <output name="assembly_info" ftype="tabular">
                <assert_contents>
                    <has_size value="286" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_graph" ftype="graph_dot">
                <assert_contents>
                    <has_size value="1248" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_gfa" ftype="txt">
                <assert_contents>
                    <has_size value="420252" delta="100"/>
               </assert_contents>
            </output>
            <output name="consensus" ftype="fasta">
                <assert_contents>
                    <has_size value="427129" delta="100"/>
               </assert_contents>
            </output>
        </test>
        <!--Test 06: hifi error option-->
        <test expect_num_outputs="4">
            <param name="inputs" ftype="fastq.gz" value="ecoli_hifi_01.fastq.gz,ecoli_hifi_02.fastq.gz,ecoli_hifi_03.fastq.gz,ecoli_hifi_04.fastq.gz,ecoli_hifi_05.fastq.gz,ecoli_hifi_06.fastq.gz,ecoli_hifi_07.fastq.gz,ecoli_hifi_08.fastq.gz,ecoli_hifi_09.fastq.gz"/>
            <conditional name="mode_conditional">
                <param name="mode" value="--pacbio-hifi"/>
                <param name="hifi_error" value="0.21"/> 
            </conditional>
            <param name="min_overlap" value="1000"/>
            <output name="assembly_info" ftype="tabular">
                <assert_contents>
                    <has_size value="286" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_graph" ftype="graph_dot">
                <assert_contents>
                    <has_size value="1273" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_gfa" ftype="txt">
                <assert_contents>
                    <has_size value="420252" delta="100"/>
               </assert_contents>
            </output>
            <output name="consensus" ftype="fasta">
                <assert_contents>
                    <has_size value="427129" delta="100"/>
               </assert_contents>
            </output>
        </test>
        <!--Test 07: keep haplotypes-->
        <test expect_num_outputs="4">
            <param name="inputs" ftype="fastq.gz" value="ecoli_hifi_01.fastq.gz,ecoli_hifi_02.fastq.gz,ecoli_hifi_03.fastq.gz,ecoli_hifi_04.fastq.gz,ecoli_hifi_05.fastq.gz,ecoli_hifi_06.fastq.gz,ecoli_hifi_07.fastq.gz,ecoli_hifi_08.fastq.gz,ecoli_hifi_09.fastq.gz"/>
            <conditional name="mode_conditional">
                <param name="mode" value="--pacbio-corr"/>
                <param name="hifi_error" value="0.21"/>
            </conditional>
            <param name="min_overlap" value="1000"/>
            <param name="keep-haplotypes" value="true"/>
            <output name="assembly_info" ftype="tabular">
                <assert_contents>
                    <has_size value="286" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_graph" ftype="graph_dot">
                <assert_contents>
                    <has_size value="1273" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_gfa" ftype="txt">
                <assert_contents>
                    <has_size value="420252" delta="100"/>
               </assert_contents>
            </output>
            <output name="consensus" ftype="fasta">
                <assert_contents>
                    <has_size value="427129" delta="100"/>
               </assert_contents>
            </output>
        </test>
        <!--Test 08: scaffolding mode-->
        <test expect_num_outputs="4">
            <param name="inputs" ftype="fastq.gz" value="ecoli_hifi_01.fastq.gz,ecoli_hifi_02.fastq.gz,ecoli_hifi_03.fastq.gz,ecoli_hifi_04.fastq.gz,ecoli_hifi_05.fastq.gz,ecoli_hifi_06.fastq.gz,ecoli_hifi_07.fastq.gz,ecoli_hifi_08.fastq.gz,ecoli_hifi_09.fastq.gz"/>
            <param name="mode" value="--nano-hq"/>
            <param name="min_overlap" value="1000"/>
            <param name="scaffolding" value="true"/>
            <output name="assembly_info" ftype="tabular">
                <assert_contents>
                    <has_size value="286" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_graph" ftype="graph_dot">
                <assert_contents>
                    <has_size value="1248" delta="100"/>
               </assert_contents>
            </output>
            <output name="assembly_gfa" ftype="txt">
                <assert_contents>
                    <has_size value="420252" delta="100"/>
               </assert_contents>
            </output>
            <output name="consensus" ftype="fasta">
                <assert_contents>
                    <has_size value="427129" delta="100"/>
               </assert_contents>
            </output>
        </test>
    </tests>
    <help><![CDATA[

.. class:: infomark

**Purpose**

Flye is a de novo assembler for single molecule sequencing reads, such as those produced by PacBio and Oxford Nanopore Technologies. 
It is designed for a wide range of datasets, from small bacterial projects to large mammalian-scale assemblies. The package represents 
a complete pipeline: it takes raw PacBio/ONT reads as input and outputs polished contigs. Flye also has a special mode for metagenome 
assembly.

----

.. class:: infomark

**Quick usage**

Input reads can be in FASTA or FASTQ format, uncompressed or compressed with gz. Currently, PacBio (raw, corrected, HiFi) and ONT reads 
(raw, corrected) are supported. Expected error rates are <30% for raw, <3% for corrected, and <1% for HiFi. Note that Flye was primarily 
developed to run on raw reads. You may specify multiple files with reads (separated by spaces). Mixing different read types is not yet supported. The *--meta* o
ption enables the mode for metagenome/uneven coverage assembly.

Genome size estimate is no longer a required option. You need to provide an estimate if using *--asm-coverage* option.

To reduce memory consumption for large genome assemblies, you can use a subset of the longest reads for initial disjointig assembly by 
specifying *--asm-coverage* and *--genome-size* options. Typically, 40x coverage is enough to produce good disjointigs.

----

.. class:: infomark

**Outputs**

The main output files are:

    ::

        - Final assembly: contains contigs and possibly scaffolds (see below).
        - Final repeat graph: note that the edge sequences might be different (shorter) than contig sequences, because contigs might include multiple graph edges.
        - Extra information about contigs (such as length or coverage).

Each contig is formed by a single unique graph edge. If possible, unique contigs are extended with the sequence from flanking unresolved repeats on the graph. Thus, 
a contig fully contains the corresponding graph edge (with the same id), but might be longer then this edge. This is somewhat similar to unitig-contig relation in 
OLC assemblers. In a rare case when a repetitive graph edge is not covered by the set of "extended" contigs, it will be also output in the assembly file.

Sometimes it is possible to further order contigs into scaffolds based on the repeat graph structure. These ordered contigs will be output as a part of scaffold in 
the assembly file (with a scaffold prefix). Since it is hard to give a reliable estimate of the gap size, those gaps are represented with the default 100 Ns. 
assembly_info.txt file (below) contains additional information about how scaffolds were formed.

Extra information about contigs/scaffolds is output into the assembly_info.txt file. It is a tab-delimited table with the columns as follows:

    ::

        - Contig/scaffold id
        - Length
        - Coverage
        - Is circular, (Y)es or (N)o
        - Is repetitive, (Y)es or (N)o
        - Multiplicity (based on coverage)
        - Alternative group
        - Graph path (graph path corresponding to this contig/scaffold).

Scaffold gaps are marked with ?? symbols, and * symbol denotes a terminal graph node. Alternative contigs (representing alternative haplotypes) will have the same alt. 
group ID. Primary contigs are marked by *.

----

.. class:: infomark

**Algorithm Description**

This is a brief description of the Flye algorithm. Please refer to the manuscript for more detailed information. The draft contig extension is organized as follows:

    ::

        - K-mer counting / erroneous k-mer pre-filtering
        - Solid k-mer selection (k-mers with sufficient frequency, which are unlikely to be erroneous)
        - Contig extension. The algorithm starts from a single read and extends it with a next overlapping read (overlaps are dynamically detected using the selected solid k-mers).

Note that we do not attempt to resolve repeats at this stage, thus the reconstructed contigs might contain misassemblies. Flye then aligns the reads on these draft 
contigs using minimap2 and calls a consensus. Afterwards, Flye performs repeat analysis as follows:

    ::

        - Repeat graph is constructed from the (possibly misassembled) contigs
        - In this graph all repeats longer than minimum overlap are collapsed
        - The algorithm resolves repeats using the read information and graph structure
        - The unbranching paths in the graph are output as contigs

If enabled, after resolving bridged repeats, Trestle module attempts to resolve simple unbridged repeats (of multiplicity 2) using the heterogeneities between repeat copies. 
Finally, Flye performs polishing of the resulting assembly to correct the remaining errors:

    ::

        - Alignment of all reads to the current assembly using minimap2
        - Partition the alignment into mini-alignments (bubbles)
        - Error correction of each bubble using a maximum likelihood approach


The polishing steps could be repeated, which might slightly increase quality for some datasets.


  ]]></help>
    <expand macro="citations" />
</tool>
