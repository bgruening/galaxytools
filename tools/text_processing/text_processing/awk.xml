<tool id="tp_awk_tool" name="Text reformatting" version="@BASE_VERSION@.2">
    <description>with awk</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <requirements>
        <requirement type="package" version="4.2.0">gawk</requirement>
    </requirements>
    <version_command>awk --version | head -n 1</version_command>
    <command>
<![CDATA[
        #set $tool_input = 1
        env -i
        #for env in $envs
            '$env.name'='$env.val'
        #end for
        awk
            --sandbox
            -v FS='	'
            -v OFS='	'
            --re-interval
            -f '$awk_script'
            #if $infile and not $last
                tool_input=0
                tool_input_id='$infile.element_identifier'
                '$infile'
            #end if
            #for group in $infiles
                tool_input=$tool_input
                #set $tool_input+=1
                #for file in $group.infile
                    tool_input_id='$file.element_identifier'
                    '$file'
                #end for
            #end for
            #if $infile and $last
                tool_input=0
                '$infile'
            #end if
        > '$outfile'
]]>
    </command>
    <configfiles>
        <configfile name="awk_script">$code</configfile>
    </configfiles>
    <inputs>
        <param name="infile" format="txt" type="data" optional="true" label="Single file to process" help="A separate execution will occur for each provided file"/>
        <param name="last" type="boolean" checked="false" label="Include the above file last" help="Include the above input after any of the below inputs" />
        <repeat name="infiles" title="Multiple input files">
            <param name="infile" format="txt" type="data" multiple="true" label="File to process" />
        </repeat>
        <param name="code" type="text" area="true" size="5x35" label="AWK Program" help="">
            <sanitizer sanitize="false" />
        </param>
        <repeat name="envs" title="Environment Variables">
            <param name="name" type="text" label="Name">
                <sanitizer>
                    <valid initial="string.printable">
                        <remove value="&apos;" />
                    </valid>
                </sanitizer>
            </param>
            <param name="val" type="text" label="Value">
                <sanitizer>
                    <valid initial="string.printable">
                        <remove value="&apos;" />
                    </valid>
                </sanitizer>
            </param>
        </repeat>
    </inputs>
    <outputs>
        <data name="outfile" format_source="infile" metadata_source="infile"/>
    </outputs>
    <tests>
        <test>
            <param name="infile" value="awk1.txt" />
            <!-- commas are not allowed in a value field. Values with comma will be splitted -->
            <param name="code" value='$2>0.5 { print $2*9"\t"$1 }' />
            <output name="outfile" file="awk_results1.txt" />
        </test>
        <test>
            <param name="infile">
                <collection type="list">
                    <element name="one" value="awk2.newick" ftype="newick" />
                    <element name="two" value="awk2.txt" ftype="txt" />
                </collection>
            </param>
            <repeat name="infiles">
                <param name="infile">
                    <collection type="list">
                        <element name="one" value="awk2.1.fa" ftype="fasta" />
                        <element name="two" value="awk2.2.fa" ftype="fasta" />
                    </collection>
                </param>
            </repeat>
            <param name="last" value="true" />
            <param name="code" value="BEGIN {delete seq[0]; seq_i = 0} match($0, /^>([^ ]+)/, a) &amp;&amp; tool_input>0 { seq[&quot;seq&quot; (seq_i++)] = a[1]; nextfile } tool_input==0 { for (i in seq) gsub(i, seq[i]); print $0}" />
            <output name="outfile" file="awk_results2.txt" >
                <assert_contents>
                    <has_text text="NC_002516"/>
                    <has_text text="NC_018080"/>
                    <not_has_text text="seq0"/>
                    <not_has_text text="seq1"/>
                </assert_contents>
            </output>
        </test>
    </tests>
    <help>
<![CDATA[
**What it does**

This tool runs the unix **awk** command on the selected data file.

.. class:: infomark

**TIP:**

This tool uses the **extended regular** expression syntax (not the perl syntax).
**\\d**, **\\w**, **\\s** etc. are **not** supported.

A variable 'tool_input' will be set to the index of the inputs, in order. The single input will always be tool_input=0.
You can combine this with ARGIND to determine which file you are currently operating on and its position in any possible input collection.
Beware that ARGIND will increment 2 between inputs as one is consumed setting tool_input.

**Further reading**

- Awk by Example (http://www.ibm.com/developerworks/linux/library/l-awk1/index.html)
- Long AWK tutorial (http://www.grymoire.com/Unix/Awk.html)

-----

**AWK programs**

Most AWK programs consist of **patterns** (i.e. rules that match lines of text) and **actions** (i.e. commands to execute when a pattern matches a line).

The basic form of AWK program is::

    pattern { action 1; action 2; action 3; }


**Pattern Examples**

- **$2 == "chr3"**  will match lines whose second column is the string 'chr3'
- **$5-$4>23**  will match lines that after subtracting the value of the fourth column from the value of the fifth column, gives value alrger than 23.
- **/AG..AG/** will match lines that contain the regular expression **AG..AG** (meaning the characeters AG followed by any two characeters followed by AG). (This is the way to specify regular expressions on the entire line, similar to GREP.)
- **$7 ~ /A{4}U/**  will match lines whose seventh column contains 4 consecutive A's followed by a U. (This is the way to specify regular expressions on a specific field.)
- **10000 < $4 && $4 < 20000** will match lines whose fourth column value is larger than 10,000 but smaller than 20,000
- **BEGIN** will be executed once only, before the first input record is read.
- If no pattern is specified, all lines match (meaning the **action** part will be executed on all lines).



**Action Examples**

- **{ print }** or **{ print $0 }**   will print the entire input line (the line that matched in **pattern**). **$0** is a special marker meaning 'the entire line'.
- **{ print $1, $4, $5 }** will print only the first, fourth and fifth fields of the input line.
- **{ print $4, $5-$4 }** will print the fourth column and the difference between the fifth and fourth column. (If the fourth column was start-position in the input file, and the fifth column was end-position - the output file will contain the start-position, and the length).
- **{ FS = "," }** can be used to change the field separator (delimeter) for parsing the input file.
- If no action part is specified (not even the curly brackets) - the default action is to print the entire line.


**AWK's Regular Expression Syntax**

The select tool searches the data for lines containing or not containing a match to the given pattern. A Regular Expression is a pattern descibing a certain amount of text.

- **( ) { } [ ] . * ? + \ ^ $** are all special characters. **\\** can be used to "escape" a special character, allowing that special character to be searched for.
- **^** matches the beginning of a string(but not an internal line).
- **(** .. **)** groups a particular pattern.
- **{** n or n, or n,m **}** specifies an expected number of repetitions of the preceding pattern.

  - **{n}** The preceding item is matched exactly n times.
  - **{n,}** The preceding item ismatched n or more times.
  - **{n,m}** The preceding item is matched at least n times but not more than m times.

- **[** ... **]** creates a character class. Within the brackets, single characters can be placed. A dash (-) may be used to indicate a range such as **a-z**.
- **.** Matches any single character except a newline.
- ***** The preceding item will be matched zero or more times.
- **?** The preceding item is optional and matched at most once.
- **+** The preceding item will be matched one or more times.
- **^** has two meaning:
  - matches the beginning of a line or string.
  - indicates negation in a character class. For example, [^...] matches every character except the ones inside brackets.
- **$** matches the end of a line or string.
- **\|** Separates alternate possibilities.

@REFERENCES@
]]>
  </help>
  <expand macro="citations" />
</tool>
